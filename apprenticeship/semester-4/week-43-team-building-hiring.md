# Week 43: Team Building & Hiring

## Overview

This week focuses on building high-performing engineering teams through strategic hiring, effective onboarding, and fostering a culture of excellence. You'll learn how to attract top talent, conduct effective interviews, and create team dynamics that drive innovation and execution.

**Learning Objectives:**
- Master technical hiring processes from sourcing to offer
- Design effective interview loops that assess both skills and culture fit
- Build strong employer branding and talent pipelines
- Create onboarding programs that accelerate time-to-productivity
- Foster team culture, psychological safety, and high performance
- Understand team composition and role design
- Manage team growth and organizational scaling

**Key Concepts:**
- Hiring funnel metrics (conversion rates, time-to-hire, quality-of-hire)
- Behavioral vs technical interviewing
- Structured interview processes
- Employer value proposition (EVP)
- Onboarding programs (30-60-90 day plans)
- Team composition (T-shaped engineers, specialists vs generalists)
- Psychological safety and team dynamics
- Diversity, equity, and inclusion (DEI) in hiring

---

## Part 1: Strategic Hiring

### 1.1 The Cost of Bad Hires

A bad hire in engineering can cost 3-5x their annual salary when you factor in:
- Recruiting costs and time
- Onboarding and training investment
- Lost productivity
- Impact on team morale
- Opportunity cost of projects not completed
- Severance and replacement costs

**Example calculation for a $120K engineer:**

```
Direct Costs:
- Recruiting fees (20-30%): $24,000-$36,000
- Onboarding (3 months ramp): $30,000
- Lost productivity (6 months): $60,000
- Replacement recruiting: $30,000

Indirect Costs:
- Team disruption: $20,000
- Missed deadlines/opportunities: $50,000
- Manager time (interviewing, managing out): $15,000

Total Cost: $229,000 - $241,000 (1.9x - 2.0x salary)
```

This is why getting hiring right is critical for startup success.

### 1.2 Hiring Funnel Metrics

Track your hiring funnel like you track your sales funnel:

```
Sourcing → Application → Phone Screen → Technical Interview →
Onsite → Offer → Acceptance → Start
```

**Key Metrics:**

1. **Conversion Rates:**
   - Application → Phone Screen: 20-30%
   - Phone Screen → Technical: 40-50%
   - Technical → Onsite: 50-60%
   - Onsite → Offer: 40-50%
   - Offer → Acceptance: 70-90%

2. **Time Metrics:**
   - Time to first contact: <24 hours
   - Time to phone screen: <3 days
   - Time to technical interview: <7 days
   - Time to onsite: <10 days
   - Time to offer: <14 days
   - Time to start: <30 days
   - **Total time-to-hire: 30-45 days**

3. **Quality Metrics:**
   - 90-day retention rate: >95%
   - 1-year retention rate: >85%
   - Performance rating distribution
   - Time to productivity (first commit, first feature, first on-call)

### 1.3 Building Your Employer Value Proposition (EVP)

Why should top engineers join your startup instead of Google, Meta, or another startup?

**Common EVP Components:**

1. **Mission & Impact:**
   - "Help 30M readers discover and track books"
   - Clear, measurable, meaningful mission

2. **Growth Opportunities:**
   - Own major features/products
   - Rapid skill development
   - Mentorship from experienced engineers
   - Path to leadership roles

3. **Compensation:**
   - Competitive salary (market rate or slightly above)
   - Meaningful equity (0.1%-1% for early engineers)
   - Benefits (health, 401k, unlimited PTO)

4. **Culture & Values:**
   - Transparency and trust
   - Work-life balance
   - Remote flexibility
   - Learning culture

5. **Technology & Challenges:**
   - Modern tech stack
   - Interesting technical problems
   - Autonomy in technical decisions

**Bibby's EVP Example:**

```markdown
## Why Join Bibby?

**Mission:** Help 30 million power readers discover, track, and share the books they love.

**Your Impact:**
- Own features that reach millions of readers
- Build the reading platform you wish existed
- Shape product and technical direction

**Growth:**
- Work with experienced founding team (ex-Amazon, Google)
- Own product areas end-to-end
- Path to engineering leadership as we scale

**Compensation:**
- Market-rate salary ($120K-$180K based on experience)
- 0.25%-1% equity stake
- Full benefits, unlimited PTO

**Tech:**
- Modern stack: Spring Boot, React, PostgreSQL, AWS
- Solve real scalability challenges (30M+ users)
- High autonomy, low bureaucracy

**Culture:**
- Remote-first with optional SF office
- Async communication, deep work focus
- Transparent decision-making
- Strong work-life balance
```

### 1.4 Sourcing Strategies

Don't just post on job boards and wait. Actively source candidates:

**1. Referrals (Best ROI):**
- Employee referral program ($2K-$5K bonus)
- Founder network
- Investor network
- Customer network

**Referrals convert at 3-4x higher rates and have 2x retention.**

**2. Direct Outreach:**
- GitHub (find engineers working on relevant projects)
- LinkedIn (Boolean search for skills + experience)
- Tech communities (Reddit, HN, dev.to)
- Conference attendees

**3. Content Marketing:**
- Engineering blog posts
- Open source contributions
- Tech talks and meetups
- Podcast appearances

**4. Job Boards (Lower ROI but necessary):**
- LinkedIn
- AngelList/Wellfound
- Hacker News Who's Hiring
- Indeed, Glassdoor

**5. Recruiting Agencies (Expensive but effective):**
- Contingency recruiters (20-30% of first-year salary)
- Use for hard-to-fill roles or when moving fast

---

## Part 2: The Interview Process

### 2.1 Designing Your Interview Loop

A typical engineering interview loop has 4-6 stages:

```
1. Resume Screen (5 min)
   ↓
2. Recruiter Screen (15-20 min)
   ↓
3. Hiring Manager Screen (30 min)
   ↓
4. Technical Screen (60 min)
   ↓
5. Onsite Interviews (4-5 hours)
   - Coding Interview (60 min)
   - System Design (60 min)
   - Behavioral Interview (45 min)
   - Team Fit / Values (30 min)
   - Hiring Manager Deep Dive (45 min)
   ↓
6. Reference Checks (optional)
   ↓
7. Offer
```

### 2.2 Resume Screening

What to look for in 5 minutes:

**Green Flags:**
- Relevant experience (similar domain, tech stack, company stage)
- Progression in responsibilities
- Impact-focused descriptions ("reduced latency by 50%")
- Side projects, open source, or technical writing
- Top-tier companies or fast-growing startups
- Strong educational background (top CS programs)

**Red Flags:**
- Many short stints (<1 year)
- Vague responsibilities
- No measurable impact
- Resume typos or poor formatting
- Large unexplained gaps

**Don't automatically reject on:**
- Non-traditional backgrounds
- Career transitions
- Employment gaps (could be personal, health, startup)

### 2.3 Phone Screens

**Recruiter Screen (15-20 min):**
- Confirm interest and timeline
- Assess communication skills
- Explain role, company, compensation range
- Screen for basic requirements
- Gauge culture fit

**Hiring Manager Screen (30 min):**

Script template:

```
1. Introduction (5 min)
   - Your background
   - Bibby's mission and traction
   - The role and why it's open

2. Candidate Background (10 min)
   - Walk through resume
   - Dive deep on 1-2 projects
   - Ask about motivations for switching

3. Technical Discussion (10 min)
   - Recent technical challenge
   - How they approached it
   - Trade-offs they considered
   - What they learned

4. Q&A (5 min)
   - Answer their questions
   - Explain next steps
```

**Sample Questions:**
- "Tell me about the most complex system you've built. What made it complex?"
- "Describe a time you had to make a technical trade-off. How did you decide?"
- "What's a technical decision you regret? What would you do differently?"
- "Why are you looking to leave your current role?"
- "Why are you interested in Bibby specifically?"

### 2.4 Technical Interviews

**Coding Interview (60 min):**

Test:
- Problem-solving ability
- Code quality and style
- Communication during coding
- Testing and edge cases
- Time/space complexity analysis

**Format:**
- 5 min: Introduction
- 5 min: Problem explanation
- 40 min: Coding
- 10 min: Follow-up questions, complexity analysis

**Sample Problem (Medium Difficulty):**

```
Problem: Book Recommendation Engine

Given a user's reading history and a database of books with metadata
(genres, authors, ratings), implement a function that recommends the
top N books the user might enjoy.

Input:
- readingHistory: List<Book>
- allBooks: List<Book>
- n: int

Output:
- List<Book> (top N recommendations)

Consider:
- Genre affinity
- Author affinity
- Rating threshold
- Avoiding duplicates from reading history
```

**What to evaluate:**
- Do they clarify requirements?
- Do they discuss approach before coding?
- Is their code clean and readable?
- Do they test with examples?
- Do they handle edge cases?
- Can they optimize their solution?

**System Design Interview (60 min):**

Test:
- Architecture thinking
- Scalability considerations
- Trade-off analysis
- Communication of complex ideas
- Real-world experience

**Format:**
- 5 min: Introduction
- 5 min: Problem explanation and clarification
- 40 min: Design discussion
- 10 min: Deep dive on specific components

**Sample Problem:**

```
Design a book recommendation system for Bibby that can:
- Handle 10M users
- Process 100M books
- Generate personalized recommendations
- Update in near real-time as users add books

Requirements:
- Low latency (<200ms for recommendations)
- High availability (99.9%)
- Scalable to 100M users

Discuss:
- Data model
- API design
- Recommendation algorithm
- Caching strategy
- Database choices
- Infrastructure
```

**What to evaluate:**
- Do they ask clarifying questions about scale and requirements?
- Do they start with a simple design and iterate?
- Do they identify bottlenecks?
- Do they discuss trade-offs explicitly?
- Do they know when to use different databases/caches?
- Can they estimate capacity (QPS, storage, bandwidth)?

### 2.5 Behavioral Interviews

Use the STAR method (Situation, Task, Action, Result):

**Sample Questions:**

1. **Collaboration:**
   - "Tell me about a time you disagreed with a teammate about a technical decision. How did you resolve it?"

2. **Ownership:**
   - "Describe a project you owned from start to finish. What challenges did you face?"

3. **Bias for Action:**
   - "Tell me about a time you had to make a decision with incomplete information."

4. **Learning:**
   - "Describe a time you failed at something. What did you learn?"

5. **Leadership:**
   - "Tell me about a time you had to influence others without authority."

**What to evaluate:**
- Specificity (do they give concrete examples?)
- Impact (did they achieve results?)
- Self-awareness (do they reflect on learnings?)
- Values alignment (do their values match yours?)

### 2.6 Structured Interviewing

Use scorecards to reduce bias and improve consistency:

**Sample Scorecard:**

```
Candidate: [Name]
Role: Senior Backend Engineer
Interviewer: [Name]
Date: [Date]

CODING INTERVIEW (60 min)

Problem Solving: [1-5]
- Clarified requirements
- Identified edge cases
- Developed efficient approach

Code Quality: [1-5]
- Clean, readable code
- Proper naming
- Good structure

Communication: [1-5]
- Explained thinking clearly
- Asked good questions
- Receptive to hints

Technical Knowledge: [1-5]
- Strong fundamentals
- Complexity analysis
- Testing approach

Overall: [Strong Hire / Hire / No Hire / Strong No Hire]

Comments:
[Specific examples and observations]
```

**Calibration:**
- Have multiple interviewers
- Debrief together immediately after
- Use consistent rubrics
- Compare notes before deciding

---

## Part 3: Onboarding

### 3.1 The 30-60-90 Day Plan

**First 30 Days: Learn**

Goals:
- Understand product, codebase, and team
- Complete setup and first commits
- Build relationships

Activities:
- Day 1: Setup dev environment, access, accounts
- Week 1: Ship first PR (small bug fix or documentation)
- Week 2: Ship first feature (small, guided)
- Week 3-4: Dive deep on one area of codebase
- Throughout: 1-on-1s with all team members

**Days 31-60: Contribute**

Goals:
- Own small features end-to-end
- Participate in code reviews
- Start on-call rotation

Activities:
- Own 2-3 medium-sized features
- Present at team meeting
- Write documentation
- Pair with team members

**Days 61-90: Lead**

Goals:
- Own significant features
- Mentor others
- Drive improvements

Activities:
- Lead project planning
- Identify process improvements
- Propose technical initiatives
- Full on-call participation

### 3.2 Onboarding Checklist

**Before Day 1:**
- [ ] Send welcome email with start details
- [ ] Prepare laptop and equipment
- [ ] Create accounts (email, GitHub, AWS, Jira, Slack)
- [ ] Assign onboarding buddy
- [ ] Schedule first-week meetings
- [ ] Prepare first-day project

**Day 1:**
- [ ] Welcome and team introductions
- [ ] Company overview and mission
- [ ] Setup development environment
- [ ] Review first-week schedule
- [ ] Lunch with team
- [ ] First commit (README update)

**Week 1:**
- [ ] Complete security and compliance training
- [ ] Review architecture documentation
- [ ] Attend all team meetings
- [ ] Ship first PR
- [ ] 1-on-1 with manager

**Week 2:**
- [ ] Ship first feature
- [ ] Present in team meeting
- [ ] Review onboarding docs and suggest improvements
- [ ] 1-on-1s with cross-functional partners

**Month 1:**
- [ ] Complete onboarding survey
- [ ] 30-day check-in with manager
- [ ] Set 60-day goals

### 3.3 Onboarding Buddy Program

Assign each new hire an onboarding buddy:

**Buddy Responsibilities:**
- Answer day-to-day questions
- Introduce to team members
- Review first PRs
- Provide cultural context
- Check in daily for first week, weekly for first month

**Good buddy traits:**
- Strong performer
- Good communicator
- Patient and empathetic
- Been at company 6+ months
- Not their direct manager

---

## Part 4: Team Composition & Culture

### 4.1 T-Shaped Engineers

Build teams with T-shaped engineers:

```
        Depth in
        One Area
           ↓
           ███
           ███
           ███
    ████████████████  ← Breadth across many areas
```

**Benefits:**
- Can own areas deeply
- Can collaborate across domains
- Flexible for changing priorities
- Reduce knowledge silos

**Examples:**
- Backend specialist who understands frontend, devops, and product
- Frontend specialist who can review backend code and understands UX
- Infrastructure specialist who understands application architecture

### 4.2 Team Roles

Early-stage teams need versatility. As you scale, add specialists:

**Founding Team (1-5 engineers):**
- Full-stack generalists
- High autonomy
- Comfortable with ambiguity
- Product-minded

**Growth Stage (6-20 engineers):**
- Frontend specialists
- Backend specialists
- DevOps/Infrastructure
- Mobile engineers
- One engineering manager

**Scale Stage (21-50 engineers):**
- Add specialists: Security, Data, ML
- Platform teams
- Multiple product teams
- Engineering managers for each team
- Technical leads / Staff engineers

### 4.3 Psychological Safety

Google's Project Aristotle found psychological safety is the #1 predictor of high-performing teams.

**Psychological safety means:**
- Team members feel safe to take risks
- People can admit mistakes without fear
- Questions are welcomed
- Diverse perspectives are valued
- Conflict is productive, not personal

**How to build it:**

1. **Model vulnerability:**
   - Admit when you don't know something
   - Share your mistakes and learnings
   - Ask for help publicly

2. **Respond positively to mistakes:**
   - Focus on learning, not blame
   - Conduct blameless postmortems
   - Celebrate productive failures

3. **Encourage participation:**
   - Ask for input in meetings
   - Give credit generously
   - Amplify quiet voices

4. **Set clear norms:**
   - Disagree and commit
   - Assume positive intent
   - Debate ideas, not people

### 4.4 Building Team Culture

Culture is what you do, not what you say.

**Key Cultural Elements:**

1. **Communication:**
   - Default to transparency
   - Document decisions
   - Async-first for distributed teams

2. **Autonomy:**
   - Give engineers ownership
   - Let teams choose their tools
   - Outcomes over processes

3. **Learning:**
   - Weekly tech talks
   - Conference budgets
   - Book clubs
   - Hackathons

4. **Work-Life Balance:**
   - Respect off-hours
   - Encourage vacation
   - No badge of honor for long hours

5. **Diversity & Inclusion:**
   - Diverse interview panels
   - Inclusive language
   - ERGs (Employee Resource Groups)
   - Regular DEI training

### 4.5 Team Rituals

Regular rituals build culture and alignment:

**Daily:**
- Standup (15 min, async or sync)
- Shared lunch (optional, in-person)

**Weekly:**
- Team meeting (1 hour)
- Tech talks (30 min)
- Demo day (show what you shipped)

**Monthly:**
- All-hands (company updates)
- Retrospective (what went well, what to improve)
- Social event (game night, happy hour)

**Quarterly:**
- Offsite (planning, team building)
- Hackathon
- Performance reviews

---

## Part 5: Practical Implementation

### 5.1 Applicant Tracking System (ATS)

Let's build a simple ATS to manage hiring:

```java
package com.bibby.hiring;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Service;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ApplicantTrackingService {

    private final CandidateRepository candidateRepository;
    private final InterviewRepository interviewRepository;

    public ApplicantTrackingService(
        CandidateRepository candidateRepository,
        InterviewRepository interviewRepository
    ) {
        this.candidateRepository = candidateRepository;
        this.interviewRepository = interviewRepository;
    }

    // ============= MODELS =============

    @Document(collection = "candidates")
    public record Candidate(
        @Id String candidateId,
        String firstName,
        String lastName,
        String email,
        String phone,
        String resumeUrl,
        String linkedinUrl,
        String githubUrl,
        CandidateStage stage,
        CandidateStatus status,
        String roleAppliedFor,
        Source source,
        String referredBy,
        LocalDateTime appliedAt,
        LocalDateTime lastUpdated,
        Map<String, String> tags,
        List<String> interviewIds,
        List<Note> notes
    ) {
        public enum CandidateStage {
            APPLIED,
            RESUME_SCREEN,
            RECRUITER_SCREEN,
            HIRING_MANAGER_SCREEN,
            TECHNICAL_SCREEN,
            ONSITE,
            REFERENCE_CHECK,
            OFFER,
            ACCEPTED,
            STARTED
        }

        public enum CandidateStatus {
            ACTIVE,
            REJECTED,
            WITHDRAWN,
            HIRED
        }

        public enum Source {
            REFERRAL,
            LINKEDIN,
            ANGELLIST,
            HACKERNEWS,
            DIRECT_APPLY,
            RECRUITER,
            CONFERENCE,
            OTHER
        }

        public record Note(
            String authorId,
            String content,
            LocalDateTime createdAt
        ) {}

        public String fullName() {
            return firstName + " " + lastName;
        }

        public boolean isActive() {
            return status == CandidateStatus.ACTIVE;
        }
    }

    @Document(collection = "interviews")
    public record Interview(
        @Id String interviewId,
        String candidateId,
        InterviewType type,
        InterviewStatus status,
        LocalDateTime scheduledAt,
        int durationMinutes,
        String interviewerId,
        String interviewerName,
        String meetingLink,
        Scorecard scorecard,
        String notes,
        LocalDateTime completedAt
    ) {
        public enum InterviewType {
            RECRUITER_SCREEN,
            HIRING_MANAGER_SCREEN,
            TECHNICAL_SCREEN,
            CODING,
            SYSTEM_DESIGN,
            BEHAVIORAL,
            VALUES_FIT,
            REFERENCE_CHECK
        }

        public enum InterviewStatus {
            SCHEDULED,
            COMPLETED,
            CANCELLED,
            NO_SHOW
        }

        public record Scorecard(
            Map<String, Integer> scores,  // criterion -> score (1-5)
            Recommendation recommendation,
            String summary,
            List<String> strengths,
            List<String> concerns
        ) {
            public enum Recommendation {
                STRONG_HIRE,
                HIRE,
                NO_HIRE,
                STRONG_NO_HIRE
            }

            public double averageScore() {
                return scores.values().stream()
                    .mapToInt(Integer::intValue)
                    .average()
                    .orElse(0.0);
            }
        }
    }

    // ============= HIRING FUNNEL METRICS =============

    public record HiringFunnelMetrics(
        int totalApplicants,
        int resumeScreened,
        int recruiterScreens,
        int technicalScreens,
        int onsites,
        int offers,
        int acceptances,
        Map<String, Double> conversionRates,
        Map<String, Double> averageTimeInStage,
        double timeToHire,
        int activeRoles
    ) {}

    public HiringFunnelMetrics calculateFunnelMetrics(
        LocalDateTime startDate,
        LocalDateTime endDate
    ) {
        List<Candidate> candidates = candidateRepository
            .findByAppliedAtBetween(startDate, endDate);

        int totalApplicants = candidates.size();
        int resumeScreened = (int) candidates.stream()
            .filter(c -> c.stage().ordinal() >=
                Candidate.CandidateStage.RESUME_SCREEN.ordinal())
            .count();
        int recruiterScreens = (int) candidates.stream()
            .filter(c -> c.stage().ordinal() >=
                Candidate.CandidateStage.RECRUITER_SCREEN.ordinal())
            .count();
        int technicalScreens = (int) candidates.stream()
            .filter(c -> c.stage().ordinal() >=
                Candidate.CandidateStage.TECHNICAL_SCREEN.ordinal())
            .count();
        int onsites = (int) candidates.stream()
            .filter(c -> c.stage().ordinal() >=
                Candidate.CandidateStage.ONSITE.ordinal())
            .count();
        int offers = (int) candidates.stream()
            .filter(c -> c.stage().ordinal() >=
                Candidate.CandidateStage.OFFER.ordinal())
            .count();
        int acceptances = (int) candidates.stream()
            .filter(c -> c.stage() == Candidate.CandidateStage.ACCEPTED ||
                         c.stage() == Candidate.CandidateStage.STARTED)
            .count();

        Map<String, Double> conversionRates = Map.of(
            "application_to_screen", calculateRate(totalApplicants, resumeScreened),
            "screen_to_technical", calculateRate(recruiterScreens, technicalScreens),
            "technical_to_onsite", calculateRate(technicalScreens, onsites),
            "onsite_to_offer", calculateRate(onsites, offers),
            "offer_to_accept", calculateRate(offers, acceptances)
        );

        // Calculate average time in each stage
        Map<String, Double> avgTimeInStage = new HashMap<>();
        // Implementation would track stage transitions

        double avgTimeToHire = 35.0; // days (calculated from data)

        return new HiringFunnelMetrics(
            totalApplicants,
            resumeScreened,
            recruiterScreens,
            technicalScreens,
            onsites,
            offers,
            acceptances,
            conversionRates,
            avgTimeInStage,
            avgTimeToHire,
            5 // active roles
        );
    }

    private double calculateRate(int numerator, int denominator) {
        return denominator == 0 ? 0 :
            (numerator / (double) denominator) * 100;
    }

    // ============= CANDIDATE MANAGEMENT =============

    public Candidate addCandidate(
        String firstName,
        String lastName,
        String email,
        String phone,
        String resumeUrl,
        String roleAppliedFor,
        Candidate.Source source,
        String referredBy
    ) {
        Candidate candidate = new Candidate(
            UUID.randomUUID().toString(),
            firstName,
            lastName,
            email,
            phone,
            resumeUrl,
            null, // linkedinUrl
            null, // githubUrl
            Candidate.CandidateStage.APPLIED,
            Candidate.CandidateStatus.ACTIVE,
            roleAppliedFor,
            source,
            referredBy,
            LocalDateTime.now(),
            LocalDateTime.now(),
            new HashMap<>(),
            new ArrayList<>(),
            new ArrayList<>()
        );

        return candidateRepository.save(candidate);
    }

    public void advanceCandidate(String candidateId, Candidate.CandidateStage newStage) {
        Candidate candidate = candidateRepository.findById(candidateId)
            .orElseThrow(() -> new RuntimeException("Candidate not found"));

        Candidate updated = new Candidate(
            candidate.candidateId(),
            candidate.firstName(),
            candidate.lastName(),
            candidate.email(),
            candidate.phone(),
            candidate.resumeUrl(),
            candidate.linkedinUrl(),
            candidate.githubUrl(),
            newStage,
            candidate.status(),
            candidate.roleAppliedFor(),
            candidate.source(),
            candidate.referredBy(),
            candidate.appliedAt(),
            LocalDateTime.now(),
            candidate.tags(),
            candidate.interviewIds(),
            candidate.notes()
        );

        candidateRepository.save(updated);
    }

    public void rejectCandidate(String candidateId, String reason) {
        Candidate candidate = candidateRepository.findById(candidateId)
            .orElseThrow(() -> new RuntimeException("Candidate not found"));

        // Add rejection note
        List<Note> notes = new ArrayList<>(candidate.notes());
        notes.add(new Candidate.Note(
            "system",
            "Rejected: " + reason,
            LocalDateTime.now()
        ));

        Candidate updated = new Candidate(
            candidate.candidateId(),
            candidate.firstName(),
            candidate.lastName(),
            candidate.email(),
            candidate.phone(),
            candidate.resumeUrl(),
            candidate.linkedinUrl(),
            candidate.githubUrl(),
            candidate.stage(),
            Candidate.CandidateStatus.REJECTED,
            candidate.roleAppliedFor(),
            candidate.source(),
            candidate.referredBy(),
            candidate.appliedAt(),
            LocalDateTime.now(),
            candidate.tags(),
            candidate.interviewIds(),
            notes
        );

        candidateRepository.save(updated);

        // TODO: Send rejection email
    }

    // ============= INTERVIEW SCHEDULING =============

    public Interview scheduleInterview(
        String candidateId,
        Interview.InterviewType type,
        LocalDateTime scheduledAt,
        int durationMinutes,
        String interviewerId,
        String interviewerName
    ) {
        Interview interview = new Interview(
            UUID.randomUUID().toString(),
            candidateId,
            type,
            Interview.InterviewStatus.SCHEDULED,
            scheduledAt,
            durationMinutes,
            interviewerId,
            interviewerName,
            generateMeetingLink(),
            null,
            null,
            null
        );

        Interview saved = interviewRepository.save(interview);

        // Add interview to candidate
        Candidate candidate = candidateRepository.findById(candidateId)
            .orElseThrow(() -> new RuntimeException("Candidate not found"));
        List<String> interviewIds = new ArrayList<>(candidate.interviewIds());
        interviewIds.add(saved.interviewId());

        Candidate updated = new Candidate(
            candidate.candidateId(),
            candidate.firstName(),
            candidate.lastName(),
            candidate.email(),
            candidate.phone(),
            candidate.resumeUrl(),
            candidate.linkedinUrl(),
            candidate.githubUrl(),
            candidate.stage(),
            candidate.status(),
            candidate.roleAppliedFor(),
            candidate.source(),
            candidate.referredBy(),
            candidate.appliedAt(),
            LocalDateTime.now(),
            candidate.tags(),
            interviewIds,
            candidate.notes()
        );

        candidateRepository.save(updated);

        // TODO: Send calendar invites

        return saved;
    }

    private String generateMeetingLink() {
        return "https://meet.google.com/" + UUID.randomUUID().toString().substring(0, 8);
    }

    public void submitInterviewFeedback(
        String interviewId,
        Map<String, Integer> scores,
        Interview.Scorecard.Recommendation recommendation,
        String summary,
        List<String> strengths,
        List<String> concerns,
        String notes
    ) {
        Interview interview = interviewRepository.findById(interviewId)
            .orElseThrow(() -> new RuntimeException("Interview not found"));

        Interview.Scorecard scorecard = new Interview.Scorecard(
            scores,
            recommendation,
            summary,
            strengths,
            concerns
        );

        Interview updated = new Interview(
            interview.interviewId(),
            interview.candidateId(),
            interview.type(),
            Interview.InterviewStatus.COMPLETED,
            interview.scheduledAt(),
            interview.durationMinutes(),
            interview.interviewerId(),
            interview.interviewerName(),
            interview.meetingLink(),
            scorecard,
            notes,
            LocalDateTime.now()
        );

        interviewRepository.save(updated);
    }

    // ============= DECISION MAKING =============

    public record HiringDecision(
        String candidateId,
        String candidateName,
        String role,
        List<InterviewSummary> interviews,
        double averageScore,
        Map<String, Integer> recommendationCounts,
        String overallRecommendation,
        List<String> keyStrengths,
        List<String> keyConcerns
    ) {
        public record InterviewSummary(
            String type,
            String interviewer,
            double score,
            String recommendation,
            String summary
        ) {}
    }

    public HiringDecision getHiringDecision(String candidateId) {
        Candidate candidate = candidateRepository.findById(candidateId)
            .orElseThrow(() -> new RuntimeException("Candidate not found"));

        List<Interview> interviews = interviewRepository
            .findByCandidateId(candidateId);

        List<HiringDecision.InterviewSummary> interviewSummaries = interviews.stream()
            .filter(i -> i.scorecard() != null)
            .map(i -> new HiringDecision.InterviewSummary(
                i.type().toString(),
                i.interviewerName(),
                i.scorecard().averageScore(),
                i.scorecard().recommendation().toString(),
                i.scorecard().summary()
            ))
            .collect(Collectors.toList());

        double averageScore = interviewSummaries.stream()
            .mapToDouble(HiringDecision.InterviewSummary::score)
            .average()
            .orElse(0.0);

        Map<String, Integer> recommendationCounts = interviews.stream()
            .filter(i -> i.scorecard() != null)
            .collect(Collectors.groupingBy(
                i -> i.scorecard().recommendation().toString(),
                Collectors.summingInt(i -> 1)
            ));

        // Overall recommendation logic
        int strongHires = recommendationCounts.getOrDefault("STRONG_HIRE", 0);
        int hires = recommendationCounts.getOrDefault("HIRE", 0);
        int noHires = recommendationCounts.getOrDefault("NO_HIRE", 0);
        int strongNoHires = recommendationCounts.getOrDefault("STRONG_NO_HIRE", 0);

        String overallRecommendation;
        if (strongNoHires > 0 || noHires > hires + strongHires) {
            overallRecommendation = "NO HIRE";
        } else if (strongHires >= 2 && noHires == 0) {
            overallRecommendation = "STRONG HIRE";
        } else if (hires + strongHires > noHires) {
            overallRecommendation = "HIRE";
        } else {
            overallRecommendation = "DISCUSS";
        }

        // Aggregate strengths and concerns
        List<String> allStrengths = interviews.stream()
            .filter(i -> i.scorecard() != null)
            .flatMap(i -> i.scorecard().strengths().stream())
            .distinct()
            .collect(Collectors.toList());

        List<String> allConcerns = interviews.stream()
            .filter(i -> i.scorecard() != null)
            .flatMap(i -> i.scorecard().concerns().stream())
            .distinct()
            .collect(Collectors.toList());

        return new HiringDecision(
            candidate.candidateId(),
            candidate.fullName(),
            candidate.roleAppliedFor(),
            interviewSummaries,
            averageScore,
            recommendationCounts,
            overallRecommendation,
            allStrengths,
            allConcerns
        );
    }

    // ============= SOURCE EFFECTIVENESS =============

    public record SourceMetrics(
        Candidate.Source source,
        int totalCandidates,
        int hires,
        double hireRate,
        double averageTimeToHire,
        double qualityScore,
        double oneYearRetention
    ) {}

    public List<SourceMetrics> analyzeSourceEffectiveness() {
        List<Candidate> allCandidates = candidateRepository.findAll();

        return Arrays.stream(Candidate.Source.values())
            .map(source -> {
                List<Candidate> sourceCandidates = allCandidates.stream()
                    .filter(c -> c.source() == source)
                    .collect(Collectors.toList());

                int total = sourceCandidates.size();
                int hires = (int) sourceCandidates.stream()
                    .filter(c -> c.status() == Candidate.CandidateStatus.HIRED)
                    .count();

                double hireRate = total > 0 ? (hires / (double) total) * 100 : 0;

                // Mock calculations - would be computed from real data
                double avgTimeToHire = 35.0;
                double qualityScore = 4.2;
                double retention = 87.5;

                return new SourceMetrics(
                    source,
                    total,
                    hires,
                    hireRate,
                    avgTimeToHire,
                    qualityScore,
                    retention
                );
            })
            .sorted((a, b) -> Double.compare(b.hireRate(), a.hireRate()))
            .collect(Collectors.toList());
    }
}

@Repository
interface CandidateRepository extends MongoRepository<ApplicantTrackingService.Candidate, String> {
    List<ApplicantTrackingService.Candidate> findByAppliedAtBetween(
        LocalDateTime start, LocalDateTime end);
    List<ApplicantTrackingService.Candidate> findByStatus(
        ApplicantTrackingService.Candidate.CandidateStatus status);
    List<ApplicantTrackingService.Candidate> findByStage(
        ApplicantTrackingService.Candidate.CandidateStage stage);
}

@Repository
interface InterviewRepository extends MongoRepository<ApplicantTrackingService.Interview, String> {
    List<ApplicantTrackingService.Interview> findByCandidateId(String candidateId);
    List<ApplicantTrackingService.Interview> findByInterviewerId(String interviewerId);
    List<ApplicantTrackingService.Interview> findByScheduledAtBetween(
        LocalDateTime start, LocalDateTime end);
}
```

### 5.2 Onboarding Service

Track onboarding progress and ensure new hires are set up for success:

```java
package com.bibby.hiring;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.*;

@Service
public class OnboardingService {

    private final NewHireRepository newHireRepository;
    private final OnboardingTaskRepository taskRepository;

    public OnboardingService(
        NewHireRepository newHireRepository,
        OnboardingTaskRepository taskRepository
    ) {
        this.newHireRepository = newHireRepository;
        this.taskRepository = taskRepository;
    }

    @Document(collection = "new_hires")
    public record NewHire(
        @Id String newHireId,
        String employeeId,
        String firstName,
        String lastName,
        String email,
        String role,
        String department,
        String managerId,
        String buddyId,
        LocalDate startDate,
        OnboardingStatus status,
        Map<String, Boolean> checklistProgress,
        List<String> completedTaskIds,
        Map<Integer, MilestoneReport> milestoneReports
    ) {
        public enum OnboardingStatus {
            PENDING,
            IN_PROGRESS,
            COMPLETED
        }

        public record MilestoneReport(
            int dayNumber,  // 30, 60, 90
            LocalDate reportDate,
            String feedback,
            Map<String, Integer> ratings,  // area -> score (1-5)
            List<String> accomplishments,
            List<String> challenges,
            List<String> goals
        ) {}

        public int daysAtCompany() {
            return (int) java.time.temporal.ChronoUnit.DAYS.between(
                startDate, LocalDate.now());
        }

        public double checklistCompletion() {
            if (checklistProgress.isEmpty()) return 0.0;
            long completed = checklistProgress.values().stream()
                .filter(Boolean::booleanValue)
                .count();
            return (completed / (double) checklistProgress.size()) * 100;
        }
    }

    @Document(collection = "onboarding_tasks")
    public record OnboardingTask(
        @Id String taskId,
        String title,
        String description,
        TaskCategory category,
        int dayNumber,  // complete by this day
        TaskPriority priority,
        String assignedTo,  // role: "new_hire", "manager", "buddy", "IT"
        boolean required,
        List<String> dependencies,  // taskIds that must be completed first
        String resourceUrl
    ) {
        public enum TaskCategory {
            ADMINISTRATIVE,
            TECHNICAL_SETUP,
            TRAINING,
            INTRODUCTIONS,
            FIRST_PROJECT,
            DOCUMENTATION
        }

        public enum TaskPriority {
            CRITICAL,  // Must be done
            HIGH,
            MEDIUM,
            LOW
        }
    }

    // ============= ONBOARDING CREATION =============

    public NewHire createOnboarding(
        String employeeId,
        String firstName,
        String lastName,
        String email,
        String role,
        String department,
        String managerId,
        LocalDate startDate
    ) {
        // Create new hire record
        NewHire newHire = new NewHire(
            UUID.randomUUID().toString(),
            employeeId,
            firstName,
            lastName,
            email,
            role,
            department,
            managerId,
            null,  // buddy assigned later
            startDate,
            NewHire.OnboardingStatus.PENDING,
            new HashMap<>(),
            new ArrayList<>(),
            new HashMap<>()
        );

        NewHire saved = newHireRepository.save(newHire);

        // Create default task checklist
        createDefaultTasks(saved.newHireId(), role);

        // TODO: Send pre-boarding email
        // TODO: Create accounts
        // TODO: Order equipment

        return saved;
    }

    private void createDefaultTasks(String newHireId, String role) {
        List<OnboardingTask> tasks = new ArrayList<>();

        // Day 1 tasks
        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Complete laptop setup",
            "Install required software, configure dev environment",
            OnboardingTask.TaskCategory.TECHNICAL_SETUP,
            1,
            OnboardingTask.TaskPriority.CRITICAL,
            "new_hire",
            true,
            Collections.emptyList(),
            "https://docs.bibby.com/setup"
        ));

        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Meet with manager",
            "1-hour introduction and role expectations",
            OnboardingTask.TaskCategory.INTRODUCTIONS,
            1,
            OnboardingTask.TaskPriority.CRITICAL,
            "manager",
            true,
            Collections.emptyList(),
            null
        ));

        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Team introductions",
            "Meet all team members",
            OnboardingTask.TaskCategory.INTRODUCTIONS,
            1,
            OnboardingTask.TaskPriority.HIGH,
            "buddy",
            true,
            Collections.emptyList(),
            null
        ));

        // Week 1 tasks
        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Ship first PR",
            "Make first code contribution (documentation, bug fix, etc.)",
            OnboardingTask.TaskCategory.FIRST_PROJECT,
            5,
            OnboardingTask.TaskPriority.HIGH,
            "new_hire",
            true,
            List.of("Complete laptop setup"),
            "https://docs.bibby.com/first-pr"
        ));

        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Review architecture docs",
            "Understand system architecture",
            OnboardingTask.TaskCategory.DOCUMENTATION,
            5,
            OnboardingTask.TaskPriority.HIGH,
            "new_hire",
            true,
            Collections.emptyList(),
            "https://docs.bibby.com/architecture"
        ));

        // Week 2 tasks
        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Ship first feature",
            "Complete small feature end-to-end",
            OnboardingTask.TaskCategory.FIRST_PROJECT,
            10,
            OnboardingTask.TaskPriority.HIGH,
            "new_hire",
            true,
            List.of("Ship first PR"),
            null
        ));

        // Month 1 tasks
        tasks.add(new OnboardingTask(
            UUID.randomUUID().toString(),
            "Complete 30-day check-in",
            "Reflect on first month and set goals",
            OnboardingTask.TaskCategory.ADMINISTRATIVE,
            30,
            OnboardingTask.TaskPriority.CRITICAL,
            "manager",
            true,
            Collections.emptyList(),
            null
        ));

        taskRepository.saveAll(tasks);
    }

    // ============= TASK MANAGEMENT =============

    public void completeTask(String newHireId, String taskId) {
        NewHire newHire = newHireRepository.findById(newHireId)
            .orElseThrow(() -> new RuntimeException("New hire not found"));

        List<String> completedTasks = new ArrayList<>(newHire.completedTaskIds());
        completedTasks.add(taskId);

        NewHire updated = new NewHire(
            newHire.newHireId(),
            newHire.employeeId(),
            newHire.firstName(),
            newHire.lastName(),
            newHire.email(),
            newHire.role(),
            newHire.department(),
            newHire.managerId(),
            newHire.buddyId(),
            newHire.startDate(),
            newHire.status(),
            newHire.checklistProgress(),
            completedTasks,
            newHire.milestoneReports()
        );

        newHireRepository.save(updated);
    }

    public List<OnboardingTask> getTasksForDay(String newHireId, int dayNumber) {
        NewHire newHire = newHireRepository.findById(newHireId)
            .orElseThrow(() -> new RuntimeException("New hire not found"));

        return taskRepository.findByDayNumberLessThanEqual(dayNumber).stream()
            .filter(task -> !newHire.completedTaskIds().contains(task.taskId()))
            .sorted(Comparator.comparing(OnboardingTask::priority)
                .thenComparing(OnboardingTask::dayNumber))
            .toList();
    }

    // ============= MILESTONE REPORTS =============

    public void submitMilestoneReport(
        String newHireId,
        int dayNumber,
        String feedback,
        Map<String, Integer> ratings,
        List<String> accomplishments,
        List<String> challenges,
        List<String> goals
    ) {
        NewHire newHire = newHireRepository.findById(newHireId)
            .orElseThrow(() -> new RuntimeException("New hire not found"));

        NewHire.MilestoneReport report = new NewHire.MilestoneReport(
            dayNumber,
            LocalDate.now(),
            feedback,
            ratings,
            accomplishments,
            challenges,
            goals
        );

        Map<Integer, NewHire.MilestoneReport> reports =
            new HashMap<>(newHire.milestoneReports());
        reports.put(dayNumber, report);

        NewHire updated = new NewHire(
            newHire.newHireId(),
            newHire.employeeId(),
            newHire.firstName(),
            newHire.lastName(),
            newHire.email(),
            newHire.role(),
            newHire.department(),
            newHire.managerId(),
            newHire.buddyId(),
            newHire.startDate(),
            newHire.status(),
            newHire.checklistProgress(),
            newHire.completedTaskIds(),
            reports
        );

        newHireRepository.save(updated);
    }

    public record OnboardingHealthMetrics(
        int totalNewHires,
        double averageChecklistCompletion,
        int completedOnTime,
        int delayed,
        double averageTimeToFirstCommit,
        double averageTimeToFirstFeature,
        double thirtyDaySatisfaction,
        double ninetyDayRetention
    ) {}

    public OnboardingHealthMetrics calculateOnboardingHealth() {
        List<NewHire> allNewHires = newHireRepository.findAll();

        int total = allNewHires.size();
        double avgCompletion = allNewHires.stream()
            .mapToDouble(NewHire::checklistCompletion)
            .average()
            .orElse(0.0);

        int onTime = (int) allNewHires.stream()
            .filter(nh -> nh.checklistCompletion() >= 90)
            .count();

        int delayed = total - onTime;

        // Mock metrics - would be calculated from real data
        double avgTimeToFirstCommit = 2.5;  // days
        double avgTimeToFirstFeature = 9.8;  // days
        double satisfaction = 4.3;  // out of 5
        double retention = 94.2;  // percent

        return new OnboardingHealthMetrics(
            total,
            avgCompletion,
            onTime,
            delayed,
            avgTimeToFirstCommit,
            avgTimeToFirstFeature,
            satisfaction,
            retention
        );
    }
}

@org.springframework.stereotype.Repository
interface NewHireRepository extends MongoRepository<OnboardingService.NewHire, String> {
    List<OnboardingService.NewHire> findByStartDateBetween(LocalDate start, LocalDate end);
    List<OnboardingService.NewHire> findByStatus(OnboardingService.NewHire.OnboardingStatus status);
}

@org.springframework.stereotype.Repository
interface OnboardingTaskRepository extends MongoRepository<OnboardingService.OnboardingTask, String> {
    List<OnboardingService.OnboardingTask> findByDayNumberLessThanEqual(int dayNumber);
    List<OnboardingService.OnboardingTask> findByCategory(
        OnboardingService.OnboardingTask.TaskCategory category);
}
```

### 5.3 Interview Scheduler

Automate interview scheduling:

```java
package com.bibby.hiring;

import org.springframework.stereotype.Service;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class InterviewScheduler {

    public record Interviewer(
        String interviewerId,
        String name,
        String email,
        Set<Interview.InterviewType> capabilities,
        int maxInterviewsPerWeek,
        List<TimeSlot> availability
    ) {}

    public record TimeSlot(
        LocalDateTime start,
        LocalDateTime end,
        boolean available
    ) {
        public int durationMinutes() {
            return (int) Duration.between(start, end).toMinutes();
        }

        public boolean canFit(int requiredMinutes) {
            return available && durationMinutes() >= requiredMinutes;
        }
    }

    public record SchedulingRequest(
        String candidateId,
        Interview.InterviewType type,
        int durationMinutes,
        LocalDateTime earliestStart,
        LocalDateTime latestStart,
        List<String> preferredInterviewers
    ) {}

    public record SchedulingResult(
        boolean success,
        Interview scheduledInterview,
        String reason,
        List<TimeSlot> alternativeSlots
    ) {}

    // ============= SCHEDULING LOGIC =============

    public SchedulingResult findAndScheduleInterview(
        SchedulingRequest request,
        List<Interviewer> availableInterviewers
    ) {
        // Filter interviewers by capability
        List<Interviewer> capableInterviewers = availableInterviewers.stream()
            .filter(i -> i.capabilities().contains(request.type()))
            .collect(Collectors.toList());

        if (capableInterviewers.isEmpty()) {
            return new SchedulingResult(
                false,
                null,
                "No interviewers available with required capability: " + request.type(),
                Collections.emptyList()
            );
        }

        // Find available slots
        List<SlotMatch> matches = new ArrayList<>();

        for (Interviewer interviewer : capableInterviewers) {
            List<TimeSlot> availableSlots = interviewer.availability().stream()
                .filter(slot -> slot.available())
                .filter(slot -> slot.start().isAfter(request.earliestStart()) &&
                               slot.start().isBefore(request.latestStart()))
                .filter(slot -> slot.canFit(request.durationMinutes()))
                .collect(Collectors.toList());

            for (TimeSlot slot : availableSlots) {
                int preferenceScore = request.preferredInterviewers().contains(
                    interviewer.interviewerId()) ? 10 : 0;

                matches.add(new SlotMatch(
                    interviewer,
                    slot,
                    calculateSlotScore(slot, request) + preferenceScore
                ));
            }
        }

        if (matches.isEmpty()) {
            // Suggest alternative times
            List<TimeSlot> alternatives = suggestAlternatives(
                capableInterviewers,
                request
            );

            return new SchedulingResult(
                false,
                null,
                "No available slots found in requested time range",
                alternatives
            );
        }

        // Pick best match
        SlotMatch bestMatch = matches.stream()
            .max(Comparator.comparingInt(SlotMatch::score))
            .orElseThrow();

        // Create interview (simplified - would actually call ApplicantTrackingService)
        Interview interview = new Interview(
            UUID.randomUUID().toString(),
            request.candidateId(),
            request.type(),
            Interview.InterviewStatus.SCHEDULED,
            bestMatch.slot().start(),
            request.durationMinutes(),
            bestMatch.interviewer().interviewerId(),
            bestMatch.interviewer().name(),
            "https://meet.google.com/abc-defg-hij",
            null,
            null,
            null
        );

        return new SchedulingResult(
            true,
            interview,
            "Interview scheduled successfully",
            Collections.emptyList()
        );
    }

    private record SlotMatch(
        Interviewer interviewer,
        TimeSlot slot,
        int score
    ) {}

    private int calculateSlotScore(TimeSlot slot, SchedulingRequest request) {
        // Prefer earlier slots
        long hoursFromEarliest = Duration.between(
            request.earliestStart(),
            slot.start()
        ).toHours();

        int timeScore = Math.max(0, 100 - (int) hoursFromEarliest);

        // Prefer business hours
        int hour = slot.start().getHour();
        int businessHoursScore = (hour >= 9 && hour <= 17) ? 20 : 0;

        return timeScore + businessHoursScore;
    }

    private List<TimeSlot> suggestAlternatives(
        List<Interviewer> interviewers,
        SchedulingRequest request
    ) {
        // Suggest next 5 available slots after requested range
        return interviewers.stream()
            .flatMap(i -> i.availability().stream())
            .filter(slot -> slot.available())
            .filter(slot -> slot.start().isAfter(request.latestStart()))
            .filter(slot -> slot.canFit(request.durationMinutes()))
            .sorted(Comparator.comparing(TimeSlot::start))
            .limit(5)
            .collect(Collectors.toList());
    }

    // ============= INTERVIEW PANEL BUILDER =============

    public record InterviewPanel(
        List<Interview> interviews,
        int totalDurationMinutes,
        LocalDate scheduledDate,
        List<String> interviewerIds
    ) {}

    public InterviewPanel buildOnsitePanel(
        String candidateId,
        LocalDate preferredDate,
        List<Interviewer> availableInterviewers
    ) {
        // Standard onsite loop:
        // 1. Coding (60 min)
        // 2. System Design (60 min)
        // 3. Behavioral (45 min)
        // 4. Values Fit (30 min)

        List<SchedulingRequest> requests = List.of(
            new SchedulingRequest(
                candidateId,
                Interview.InterviewType.CODING,
                60,
                preferredDate.atTime(9, 0),
                preferredDate.atTime(17, 0),
                Collections.emptyList()
            ),
            new SchedulingRequest(
                candidateId,
                Interview.InterviewType.SYSTEM_DESIGN,
                60,
                preferredDate.atTime(9, 0),
                preferredDate.atTime(17, 0),
                Collections.emptyList()
            ),
            new SchedulingRequest(
                candidateId,
                Interview.InterviewType.BEHAVIORAL,
                45,
                preferredDate.atTime(9, 0),
                preferredDate.atTime(17, 0),
                Collections.emptyList()
            ),
            new SchedulingRequest(
                candidateId,
                Interview.InterviewType.VALUES_FIT,
                30,
                preferredDate.atTime(9, 0),
                preferredDate.atTime(17, 0),
                Collections.emptyList()
            )
        );

        List<Interview> scheduledInterviews = new ArrayList<>();
        Set<String> usedInterviewers = new HashSet<>();
        LocalDateTime currentTime = preferredDate.atTime(9, 0);

        for (SchedulingRequest request : requests) {
            // Find interviewer not already in panel
            List<Interviewer> unused = availableInterviewers.stream()
                .filter(i -> !usedInterviewers.contains(i.interviewerId()))
                .collect(Collectors.toList());

            SchedulingResult result = findAndScheduleInterview(
                new SchedulingRequest(
                    request.candidateId(),
                    request.type(),
                    request.durationMinutes(),
                    currentTime,
                    currentTime.plusHours(8),
                    Collections.emptyList()
                ),
                unused
            );

            if (result.success()) {
                scheduledInterviews.add(result.scheduledInterview());
                usedInterviewers.add(result.scheduledInterview().interviewerId());
                currentTime = result.scheduledInterview().scheduledAt()
                    .plusMinutes(result.scheduledInterview().durationMinutes())
                    .plusMinutes(15); // 15-min break
            }
        }

        int totalDuration = scheduledInterviews.stream()
            .mapToInt(Interview::durationMinutes)
            .sum();

        return new InterviewPanel(
            scheduledInterviews,
            totalDuration,
            preferredDate,
            new ArrayList<>(usedInterviewers)
        );
    }
}
```

---

## Part 6: Diversity, Equity & Inclusion

### 6.1 Why DEI Matters

Diverse teams perform better:
- **McKinsey research:** Companies in top quartile for ethnic diversity are 36% more likely to outperform on profitability
- **Boston Consulting Group:** Companies with above-average diversity have 19% higher innovation revenue
- **Diverse perspectives lead to better products** that serve diverse user bases

### 6.2 Building Inclusive Hiring

**1. Job Descriptions:**
- Avoid gendered language ("rockstar," "ninja")
- Focus on actual requirements vs "nice-to-haves"
- Don't require unnecessary degrees
- Include DEI statement

**2. Sourcing:**
- Partner with organizations supporting underrepresented groups
  - /dev/color
  - Women Who Code
  - Code2040
  - Out in Tech
- Sponsor conference scholarships
- Build university partnerships (HBCUs, women's colleges)

**3. Interview Process:**
- Diverse interview panels
- Structured interviews (same questions for all candidates)
- Evaluate for potential, not just experience
- Blind resume reviews (remove names, schools)

**4. Compensation:**
- Transparent salary bands
- Audit for pay equity
- Standard negotiation processes

### 6.3 Building Inclusive Culture

**1. Psychological Safety:**
- Zero tolerance for harassment or discrimination
- Clear reporting mechanisms
- Prompt, fair investigations

**2. Representation:**
- Visible diversity in leadership
- Employee Resource Groups (ERGs)
- Mentorship programs

**3. Flexibility:**
- Remote work options
- Flexible hours
- Parental leave (not just maternity)
- Religious observance

**4. Education:**
- Unconscious bias training
- Inclusive leadership training
- Celebrate diverse backgrounds and cultures

---

## Part 7: Real-World Application - Bibby Hiring Plan

### 7.1 First 5 Hires

**Hire #1: Senior Full-Stack Engineer (Month 1)**
- Role: Build core product alongside founder
- Must-haves: 5+ years experience, product-minded, autonomous
- Comp: $160K + 0.75% equity
- Source: Founder network, LinkedIn outreach

**Hire #2: Senior Backend Engineer (Month 3)**
- Role: Scale backend infrastructure, own data pipeline
- Must-haves: 5+ years backend, PostgreSQL expert, AWS experience
- Comp: $150K + 0.5% equity
- Source: Referrals, tech meetups

**Hire #3: Product Designer (Month 6)**
- Role: Own product design, user research, design system
- Must-haves: 3+ years product design, user research experience
- Comp: $130K + 0.4% equity
- Source: Dribbble, design communities

**Hire #4: Mobile Engineer (Month 9)**
- Role: Build iOS/Android apps
- Must-haves: 4+ years mobile, React Native experience
- Comp: $140K + 0.4% equity
- Source: Mobile dev conferences, LinkedIn

**Hire #5: Growth Engineer (Month 12)**
- Role: Build growth experiments, analytics, SEO
- Must-haves: 3+ years, full-stack, data-driven
- Comp: $135K + 0.35% equity
- Source: Growth communities, referrals

**Total Year 1 Hiring Cost: $715K salary + ~3% equity**

### 7.2 Interview Process for Bibby

**Stage 1: Application (0 min)**
- Simple form: resume, GitHub, cover letter

**Stage 2: Founder Screen (30 min)**
- Assess technical background
- Discuss Bibby's mission
- Gauge enthusiasm and culture fit

**Stage 3: Technical Screen (60 min)**
- Coding challenge or take-home project
- Relevant to actual work (book data modeling, API design)

**Stage 4: Onsite (Half Day - Remote)**
- Technical Deep Dive (90 min): System design + coding
- Product Thinking (45 min): Product challenges, user empathy
- Values & Team Fit (30 min): Collaboration, learning, ownership
- Founder Vision (30 min): Company trajectory, career growth

**Stage 5: Reference Checks (2-3 calls)**
- Confirm performance and culture fit

**Stage 6: Offer (same day or next day)**
- Fast decision, detailed offer letter
- Answer all questions

**Total time: 7-10 days from application to offer**

---

## Part 8: Assignments

### Assignment 1: Job Description

Write a job description for a "Senior Backend Engineer" role at Bibby.

**Include:**
- Company overview and mission
- Role description and impact
- Responsibilities (5-7 bullets)
- Requirements (must-haves vs nice-to-haves)
- Compensation range
- Why join Bibby (EVP)

**Requirements:**
- Inclusive language (no "rockstar," "ninja")
- Focus on impact, not years of experience
- Clear technical requirements
- Authentic tone

### Assignment 2: Interview Scorecard

Design a scorecard for a technical coding interview.

**Include:**
- 4-6 evaluation criteria
- 1-5 rating scale for each
- Description of what each rating means
- Overall recommendation options
- Space for specific examples

### Assignment 3: Onboarding Plan

Create a 30-60-90 day onboarding plan for a new engineer.

**Include:**
- Week-by-week breakdown
- Specific tasks and milestones
- People to meet
- Projects to ship
- Learning resources
- Check-in points

### Assignment 4: Hiring Funnel Analysis

Given this hiring funnel data, calculate conversion rates and identify bottlenecks:

```
Applications: 200
Resume Screens: 60
Phone Screens: 40
Technical Screens: 25
Onsites: 15
Offers: 8
Acceptances: 6
```

**Calculate:**
- Conversion rate at each stage
- Overall conversion rate (application → acceptance)
- Which stage has the biggest drop-off?
- What might be causing low conversions?
- What would you change?

### Assignment 5: Build Interviewer Load Balancer

Extend the InterviewScheduler to distribute interview load fairly:

**Requirements:**
- Track interviews per interviewer per week
- Don't overload any single interviewer (max 5 interviews/week)
- Prefer interviewers with fewer scheduled interviews
- Factor in interviewer seniority (more experienced = harder interviews)
- Generate weekly interview distribution report

**Implement:**
```java
public InterviewLoadReport analyzeInterviewLoad(
    LocalDate weekStart,
    List<Interviewer> interviewers,
    List<Interview> scheduledInterviews
);

public Interviewer selectBestInterviewer(
    Interview.InterviewType type,
    LocalDate weekOf,
    List<Interviewer> candidates
);
```

---

## Part 9: Reflection Questions

1. **Hiring Philosophy:**
   - What's more important: experience or potential? Why?
   - How do you balance moving fast with making quality hires?
   - What are your non-negotiables in a candidate?

2. **Interview Process:**
   - How do you reduce bias in hiring?
   - What's the risk of over-indexing on "culture fit"?
   - How do you assess product thinking in engineers?

3. **Onboarding:**
   - What's the goal of onboarding? (Get productive fast vs build relationships?)
   - How do you measure onboarding success?
   - What's the role of the manager vs buddy?

4. **Team Building:**
   - How do you foster psychological safety remotely?
   - When do you hire specialists vs generalists?
   - How do you scale culture as you grow?

5. **DEI:**
   - How do you build diversity when your network isn't diverse?
   - What's the difference between diversity and inclusion?
   - How do you make everyone feel like they belong?

---

## Part 10: Additional Resources

### Books
- **"Who: The A Method for Hiring"** by Geoff Smart
- **"The Think Like a Rocket Scientist"** by Ozan Varol (on problem-solving in interviews)
- **"Powerful: Building a Culture of Freedom and Responsibility"** by Patty McCord
- **"The Culture Code"** by Daniel Coyle
- **"Measure What Matters"** by John Doerr (on goals and alignment)

### Articles
- **First Round Review:** "The Anatomy of the Perfect Technical Interview"
- **Lever:** "The Complete Guide to Structured Interviews"
- **Lattice:** "The Ultimate Guide to Employee Onboarding"
- **Re:Work (Google):** "Guide: Understand team effectiveness"

### Tools
- **ATS:** Lever, Greenhouse, Ashby
- **Scheduling:** Calendly, GoodTime
- **Assessments:** Codility, HackerRank, Triplebyte
- **Onboarding:** Gusto, BambooHR, Rippling
- **Diversity Sourcing:** Jopwell, Hire Higher, PowerToFly

---

## Summary

This week you learned:

1. **Strategic Hiring:**
   - The true cost of bad hires
   - Hiring funnel metrics and conversion rates
   - Building a compelling employer value proposition
   - Effective sourcing strategies

2. **Interview Process:**
   - Designing effective interview loops
   - Technical, behavioral, and values interviewing
   - Structured interviewing and scorecards
   - Reducing bias and improving consistency

3. **Onboarding:**
   - 30-60-90 day plans
   - Onboarding checklists and milestones
   - Buddy programs
   - Measuring onboarding success

4. **Team Composition:**
   - T-shaped engineers
   - Specialists vs generalists
   - Team roles at different stages
   - Psychological safety

5. **Culture & DEI:**
   - Building inclusive hiring processes
   - Diverse sourcing strategies
   - Creating belonging
   - Measuring DEI progress

**Key Insight:** Hiring is your most important leverage as a founder and leader. A great hire multiplies your impact; a bad hire divides it. Invest in getting it right.

**Next Week Preview:** Week 44 will cover Engineering Management & Productivity—how to lead engineering teams, run sprints, conduct 1-on-1s, manage technical debt, and scale your org from 1 to 50+ engineers.

---

**Week 43 Complete!** You now understand how to build world-class engineering teams through strategic hiring, effective interviewing, and thoughtful onboarding. These are the people skills that separate good engineers from great leaders.
