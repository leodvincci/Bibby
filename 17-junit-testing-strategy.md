# Section 17: JUnit & Testing Strategy — Building Confidence in Your Code

**Estimated Reading Time:** 65 minutes
**Prerequisites:** Sections 1-16 (Foundation + Modern Java)
**Applies To:** Your Bibby Library Management CLI Application

---

## Table of Contents

1. [What You'll Learn](#what-youll-learn)
2. [The Testing Audit](#the-testing-audit)
3. [Why Testing Matters](#why-testing-matters)
4. [Types of Tests](#types-of-tests)
5. [JUnit 5 Basics](#junit-5-basics)
6. [The AAA Pattern](#the-aaa-pattern)
7. [What to Test (and What Not To)](#what-to-test-and-what-not-to)
8. [Testing Your BookService](#testing-your-bookservice)
9. [Assertions and Matchers](#assertions-and-matchers)
10. [Test Lifecycle](#test-lifecycle)
11. [Testing Strategy for Bibby](#testing-strategy-for-bibby)
12. [Action Items](#action-items)
13. [Key Takeaways](#key-takeaways)

---

## What You'll Learn

By the end of this section, you'll understand:

- **Current state** — Bibby has essentially 0% test coverage
- **Why testing matters** — Catch bugs before production, document behavior, enable refactoring
- **Test types** — Unit vs integration vs end-to-end
- **JUnit 5** — Annotations, assertions, lifecycle
- **AAA pattern** — Arrange, Act, Assert (structure every test this way)
- **What to test** — Business logic, edge cases, error handling
- **What NOT to test** — Getters/setters, Spring framework, database syntax
- **Real strategy** — Priority tests for Bibby services

**Most importantly**, you'll learn that tests aren't about coverage percentages—they're about **confidence**.

---

## The Testing Audit

I analyzed your Bibby codebase for test coverage:

### Current Test Files

**Count: 2 test files**

```
src/test/java/com/penrose/bibby/BibbyApplicationTests.java
src/test/java/com/penrose/bibby/cli/BookCommandsTest.java
```

**vs**

**Main Code: 41 files**

**Test Coverage Ratio: 2/41 = 4.9%** (but it's actually 0% real coverage—read on!)

---

### Test File Analysis

**BibbyApplicationTests.java:**

```java
@SpringBootTest
class BibbyApplicationTests {

    @Test
    void contextLoads() {
        // Empty! Just checks Spring context loads
    }
}
```

**Purpose:** Generated by Spring Initializr. Verifies application starts.
**Business Logic Tested:** 0%
**Value:** Low (but keep it—catches configuration errors)

---

**BookCommandsTest.java:**

```java
class BookCommandsTest {

    @Test
    public void searchByTitleTest(){
        BookEntity bookEntity = null;
        // ← EMPTY TEST! Does nothing!
    }
}
```

**Purpose:** Placeholder (never implemented)
**Business Logic Tested:** 0%
**Value:** None (doesn't even have assertions!)

---

### Critical Discovery: ZERO Real Tests

**What's Tested:**
- ✅ Spring context loads (BibbyApplicationTests)
- ❌ BookService business logic — NOT tested
- ❌ AuthorService logic — NOT tested
- ❌ BookcaseService logic — NOT tested
- ❌ ShelfService logic — NOT tested
- ❌ Repository queries — NOT tested
- ❌ CLI commands — NOT tested
- ❌ Exception handling — NOT tested
- ❌ Edge cases — NOT tested

**Real Test Coverage: 0%**

---

### What This Means

**Current State:**
- No safety net when refactoring
- Bugs discovered in production (or manual testing)
- Can't verify business logic works correctly
- Regression bugs can creep in unnoticed
- No documentation of expected behavior

**After Adding Tests:**
- Refactor with confidence (tests catch breaks)
- Bugs discovered before deployment
- Business logic verified automatically
- Regression prevented
- Tests document how code should behave

---

## Why Testing Matters

### 1. Catch Bugs Early

**Without tests:**
```
You change code → Deploy → User finds bug → Debug production → Fix → Deploy again
```

**With tests:**
```
You change code → Tests fail → Fix locally → Tests pass → Deploy with confidence
```

---

### 2. Enable Fearless Refactoring

Remember the unsafe `Optional.get()` calls from Section 15?

**Without tests:**
- Refactor BookCommands.java:361-363
- Wonder: "Did I break anything?"
- Manually test every search scenario
- Still not sure if edge cases work

**With tests:**
- Refactor BookCommands.java:361-363
- Run tests
- All green? Refactoring is safe!
- Red? You know exactly what broke

---

### 3. Document Expected Behavior

Code explains **how**, tests explain **what**.

**Code:**
```java
public BookEntity findBookByTitle(String title) {
    return Optional.ofNullable(bookRepository.findByTitleIgnoreCase(title))
        .orElseThrow(() -> new ResponseStatusException(
            HttpStatus.NOT_FOUND,
            "Book '" + title + "' not found"
        ));
}
```

**What happens if:**
- Title is null?
- Title is blank?
- Title doesn't exist?
- Multiple books match (case-insensitive)?

**Tests answer these questions:**
```java
@Test
void findBookByTitle_WhenExists_ReturnsBook() { ... }

@Test
void findBookByTitle_WhenNotFound_ThrowsException() { ... }

@Test
void findBookByTitle_WhenNull_ThrowsException() { ... }
```

Tests are **living documentation** that can't go out of date.

---

### 4. Prevent Regression

**Regression:** A bug you already fixed comes back.

**How it happens:**
1. User reports: "Search crashes with blank title"
2. You fix: Add null/blank check
3. Months later, someone refactors
4. Bug returns!

**With regression tests:**
1. User reports bug
2. Write failing test that reproduces bug
3. Fix bug (test goes green)
4. Test stays in codebase forever
5. If anyone breaks it again, test fails

**Tests are your bug radar.**

---

### 5. Faster Development (Long-Term)

**Short-term:** Tests take time to write
**Long-term:** Tests save massive time

**Scenario: Add new feature "Reserve Book"**

**Without tests:**
- Implement reserve logic
- Manually test: create book, reserve it, check status
- Test edge cases: already reserved, already checked out, doesn't exist
- Every code change requires full manual testing again
- Miss edge case → production bug → hotfix

**With tests:**
- Implement reserve logic
- Write tests for all scenarios (10 minutes)
- Run tests (5 seconds)
- Refactor with confidence
- Tests catch edge cases automatically

**After 6 months, tests have saved hours of manual testing.**

---

## Types of Tests

### 1. Unit Tests

**Test ONE unit in isolation** (usually one method).

**Characteristics:**
- Fast (milliseconds)
- No database
- No Spring context
- Mock dependencies
- Test business logic only

**Example: BookService.findBookByTitle()**

```java
@Test
void findBookByTitle_WhenExists_ReturnsBook() {
    // Arrange: Mock repository
    BookRepository mockRepo = mock(BookRepository.class);
    BookEntity expected = new BookEntity();
    expected.setTitle("1984");
    when(mockRepo.findByTitleIgnoreCase("1984")).thenReturn(expected);

    BookService service = new BookService(mockRepo, null);

    // Act: Call method
    BookEntity result = service.findBookByTitle("1984");

    // Assert: Verify result
    assertEquals("1984", result.getTitle());
}
```

**Pros:**
- ✅ Very fast
- ✅ Isolated (only tests your logic, not Spring/JPA)
- ✅ Easy to write
- ✅ Pinpoints failures

**Cons:**
- ❌ Doesn't test integration (Spring wiring, database queries)

---

### 2. Integration Tests

**Test MULTIPLE units together** (e.g., service + repository + database).

**Characteristics:**
- Slower (hundreds of milliseconds)
- Real Spring context
- Real database (or H2 in-memory)
- Tests interactions between layers

**Example: BookService + BookRepository + Database**

```java
@SpringBootTest
@Transactional
class BookServiceIntegrationTest {

    @Autowired
    private BookService bookService;

    @Autowired
    private BookRepository bookRepository;

    @Test
    void findBookByTitle_WithRealDatabase_ReturnsBook() {
        // Arrange: Insert real data
        BookEntity book = new BookEntity();
        book.setTitle("1984");
        bookRepository.save(book);

        // Act: Call service (uses real repository & database)
        BookEntity result = bookService.findBookByTitle("1984");

        // Assert
        assertNotNull(result);
        assertEquals("1984", result.getTitle());
    }
}
```

**Pros:**
- ✅ Tests real integration (Spring context, JPA queries)
- ✅ Catches configuration errors
- ✅ Verifies SQL queries work

**Cons:**
- ❌ Slower
- ❌ Harder to set up
- ❌ Failures harder to diagnose (which layer broke?)

---

### 3. End-to-End (E2E) Tests

**Test the ENTIRE system** (UI → Service → Database).

**For Bibby (CLI app):**
```java
@Test
void userCanSearchAndCheckOutBook() {
    // Simulate full user workflow
    // 1. Add book to database
    // 2. Run CLI command: book search --title "1984"
    // 3. Verify output contains book
    // 4. Run CLI command: book check-out --title "1984"
    // 5. Verify book status changed to CHECKED_OUT
}
```

**Pros:**
- ✅ Tests real user workflows
- ✅ Highest confidence

**Cons:**
- ❌ Very slow
- ❌ Brittle (break for many reasons)
- ❌ Hard to debug

---

### Testing Pyramid

```
           /\
          /E2E\          ← Few E2E tests (slow, brittle)
         /------\
        /Integr.\       ← Some integration tests (medium speed)
       /----------\
      /   Unit     \    ← Many unit tests (fast, focused)
     /--------------\
```

**Guideline:**
- **70%** unit tests (fast, isolated)
- **20%** integration tests (verify layers work together)
- **10%** E2E tests (verify critical user workflows)

**For Bibby, start with unit tests for services.**

---

## JUnit 5 Basics

### Core Annotations

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Disabled;

class BookServiceTest {

    private BookService bookService;

    @BeforeEach  // Runs before EACH test
    void setUp() {
        bookService = new BookService(mockRepo, mockAuthorRepo);
    }

    @AfterEach  // Runs after EACH test
    void tearDown() {
        // Clean up resources
    }

    @Test  // Marks a test method
    @DisplayName("Finding book by title when book exists should return the book")
    void findBookByTitle_WhenExists_ReturnsBook() {
        // Test code
    }

    @Test
    @Disabled("Not implemented yet")  // Skip this test
    void findBookByAuthor() {
        // TODO: implement
    }
}
```

---

### Assertions

**JUnit 5 Assertions:**

```java
import static org.junit.jupiter.api.Assertions.*;

// Equality
assertEquals(expected, actual);
assertEquals("1984", book.getTitle());

// Boolean
assertTrue(condition);
assertFalse(condition);
assertTrue(book.getTitle().contains("1984"));

// Null checks
assertNull(object);
assertNotNull(object);
assertNotNull(book);

// Exceptions
assertThrows(ResponseStatusException.class, () -> {
    bookService.findBookByTitle("NonExistent");
});

// Multiple assertions (all run even if one fails)
assertAll(
    () -> assertEquals("1984", book.getTitle()),
    () -> assertEquals("AVAILABLE", book.getBookStatus()),
    () -> assertNotNull(book.getBookId())
);
```

---

### AssertJ (More Readable)

**Spring Boot includes AssertJ** (more fluent API):

```java
import static org.assertj.core.api.Assertions.*;

// Clearer than JUnit assertions
assertThat(book.getTitle()).isEqualTo("1984");
assertThat(book.getTitle()).contains("84");
assertThat(book.getTitle()).isNotBlank();
assertThat(book.getTitle()).startsWith("19");

// Null checks
assertThat(book).isNotNull();
assertThat(book.getShelfId()).isNull();

// Collections
assertThat(books).hasSize(3);
assertThat(books).isEmpty();
assertThat(books).contains(book1, book2);
assertThat(books).extracting(BookEntity::getTitle)
                 .containsExactly("1984", "Brave New World");

// Exceptions
assertThatThrownBy(() -> bookService.findBookByTitle("NonExistent"))
    .isInstanceOf(ResponseStatusException.class)
    .hasMessageContaining("not found");
```

**AssertJ is more readable. Use it!**

---

## The AAA Pattern

**Every test should follow AAA:**

```
Arrange → Set up test data
Act     → Execute the code being tested
Assert  → Verify the result
```

### Example: Testing BookService.findBookByTitle()

```java
@Test
void findBookByTitle_WhenExists_ReturnsBook() {
    // ──────────────────────────────────────────────────────────
    // ARRANGE: Set up test data and dependencies
    // ──────────────────────────────────────────────────────────
    BookRepository mockRepo = mock(BookRepository.class);
    BookEntity expectedBook = new BookEntity();
    expectedBook.setTitle("1984");
    expectedBook.setBookId(1L);

    when(mockRepo.findByTitleIgnoreCase("1984")).thenReturn(expectedBook);

    BookService service = new BookService(mockRepo, null);

    // ──────────────────────────────────────────────────────────
    // ACT: Execute the method being tested
    // ──────────────────────────────────────────────────────────
    BookEntity result = service.findBookByTitle("1984");

    // ──────────────────────────────────────────────────────────
    // ASSERT: Verify the result
    // ──────────────────────────────────────────────────────────
    assertThat(result).isNotNull();
    assertThat(result.getTitle()).isEqualTo("1984");
    assertThat(result.getBookId()).isEqualTo(1L);
}
```

**Benefits:**
- ✅ Clear structure (anyone can read it)
- ✅ Easy to maintain
- ✅ Self-documenting

---

### Common AAA Mistakes

**❌ Mixing Arrange and Act:**
```java
@Test
void bad() {
    BookEntity book = new BookEntity();  // Arrange
    book.setTitle("1984");               // Arrange
    BookEntity result = service.find("1984");  // ← Act mixed with Arrange!
    assertThat(result.getTitle()).isEqualTo("1984");  // Assert
}
```

**✅ Clear AAA:**
```java
@Test
void good() {
    // Arrange
    BookEntity book = new BookEntity();
    book.setTitle("1984");
    repository.save(book);

    // Act
    BookEntity result = service.findBookByTitle("1984");

    // Assert
    assertThat(result.getTitle()).isEqualTo("1984");
}
```

---

## What to Test (and What Not To)

### ✅ Test These

**1. Business Logic**

```java
// BookService.createNewBook() has business logic:
// - Check if author exists
// - Create author if not
// - Check if book exists
// - Add book to author's books

@Test
void createNewBook_WhenAuthorExists_AddsBookToExistingAuthor() {
    // Test this logic!
}
```

**2. Edge Cases**

```java
// What if title is null?
@Test
void findBookByTitle_WhenTitleIsNull_ThrowsException() { ... }

// What if book already checked out?
@Test
void checkOutBook_WhenAlreadyCheckedOut_ThrowsException() { ... }

// What if shelf doesn't exist?
@Test
void addBookToShelf_WhenShelfNotFound_ThrowsException() { ... }
```

**3. Error Handling**

```java
// Verify exceptions are thrown correctly
@Test
void findBookByTitle_WhenNotFound_ThrowsResponseStatusException() {
    assertThatThrownBy(() -> bookService.findBookByTitle("NonExistent"))
        .isInstanceOf(ResponseStatusException.class)
        .hasMessageContaining("not found");
}
```

**4. Calculations/Transformations**

```java
// If you had price calculations:
@Test
void calculateTotalPrice_WithDiscount_ReturnsDiscountedPrice() { ... }

// String transformations:
@Test
void fullAuthorName_CombinesFirstAndLast() {
    BookRequestDTO dto = new BookRequestDTO("Book", "George", "Orwell");
    assertThat(dto.fullAuthorName()).isEqualTo("George Orwell");
}
```

---

### ❌ Don't Test These

**1. Getters and Setters**

```java
// ❌ WASTE OF TIME
@Test
void testGetTitle() {
    BookEntity book = new BookEntity();
    book.setTitle("1984");
    assertEquals("1984", book.getTitle());  // ← Duh! Of course it returns what you set!
}
```

**Why not:** You're testing Java itself, not your logic.

---

**2. Spring Framework**

```java
// ❌ WASTE OF TIME
@Test
void testSpringInjectsBookRepository() {
    assertNotNull(bookRepository);  // ← Testing Spring, not your code
}
```

**Why not:** Spring has its own tests. Trust the framework.
**Exception:** @SpringBootTest context load test is fine (catches config errors).

---

**3. Database/JPA Syntax**

```java
// ❌ DON'T test if JPA queries work (trust Spring Data)
@Test
void testFindByTitle() {
    // Save book
    // Call repository.findByTitle()
    // Assert it works
}
```

**Why not:** Spring Data has tests for query methods.
**When to test:** Custom `@Query` with complex JPQL (verify logic, not SQL syntax).

---

**4. Third-Party Libraries**

```java
// ❌ DON'T test if Mockito works
@Test
void testMockitoMocking() {
    BookRepository mock = mock(BookRepository.class);
    assertNotNull(mock);  // ← Testing Mockito, not your code
}
```

**Why not:** Libraries have their own tests.

---

**5. Simple Delegations**

```java
// ❌ DON'T test methods that just delegate
public List<BookEntity> getAllBooks() {
    return bookRepository.findAll();  // ← Just calling repository
}

@Test
void testGetAllBooks() {
    bookService.getAllBooks();
    // What are you even testing here?
}
```

**Why not:** No business logic to test.
**When to test:** If you add logic (filtering, sorting, transformation).

---

## Testing Your BookService

Let's write real tests for your actual BookService.

### Test File Structure

```java
package com.penrose.bibby.library.book;

import com.penrose.bibby.library.author.AuthorEntity;
import com.penrose.bibby.library.author.AuthorRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

import java.util.Optional;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

@DisplayName("BookService Tests")
class BookServiceTest {

    private BookService bookService;
    private BookRepository mockBookRepo;
    private AuthorRepository mockAuthorRepo;

    @BeforeEach
    void setUp() {
        // Create mocks
        mockBookRepo = mock(BookRepository.class);
        mockAuthorRepo = mock(AuthorRepository.class);

        // Create service with mocks
        bookService = new BookService(mockBookRepo, mockAuthorRepo);
    }

    // Tests go here...
}
```

---

### Test 1: findBookByTitle() - Happy Path

```java
@Test
@DisplayName("findBookByTitle() when book exists should return the book")
void findBookByTitle_WhenExists_ReturnsBook() {
    // Arrange
    BookEntity expectedBook = new BookEntity();
    expectedBook.setBookId(1L);
    expectedBook.setTitle("1984");
    expectedBook.setBookStatus("AVAILABLE");

    when(mockBookRepo.findByTitleIgnoreCase("1984"))
        .thenReturn(expectedBook);

    // Act
    Optional<BookEntity> result = bookService.findBookByTitle("1984");

    // Assert
    assertThat(result).isPresent();
    assertThat(result.get().getTitle()).isEqualTo("1984");
    assertThat(result.get().getBookId()).isEqualTo(1L);

    // Verify repository was called correctly
    verify(mockBookRepo).findByTitleIgnoreCase("1984");
}
```

**Note:** This assumes findBookByTitle() is refactored to return `Optional<BookEntity>` (from Section 15).

---

### Test 2: findBookByTitle() - Not Found

```java
@Test
@DisplayName("findBookByTitle() when book not found should throw exception")
void findBookByTitle_WhenNotFound_ThrowsException() {
    // Arrange
    when(mockBookRepo.findByTitleIgnoreCase("NonExistent"))
        .thenReturn(null);

    // Act & Assert
    assertThatThrownBy(() -> bookService.findBookByTitle("NonExistent"))
        .isInstanceOf(ResponseStatusException.class)
        .extracting("status")
        .isEqualTo(HttpStatus.NOT_FOUND);
}
```

**Note:** This assumes findBookByTitle() uses `.orElseThrow()` (from Section 15).

---

### Test 3: createNewBook() - New Author and Book

```java
@Test
@DisplayName("createNewBook() with new author and book should create both")
void createNewBook_WithNewAuthorAndBook_CreatesBoth() {
    // Arrange
    BookRequestDTO dto = new BookRequestDTO("1984", "George", "Orwell");

    when(mockAuthorRepo.findByFirstNameAndLastName("George", "Orwell"))
        .thenReturn(null);  // Author doesn't exist
    when(mockBookRepo.findByTitle("1984"))
        .thenReturn(null);  // Book doesn't exist

    // Act
    bookService.createNewBook(dto);

    // Assert
    // Verify author was saved
    verify(mockAuthorRepo).save(argThat(author ->
        author.getFirstName().equals("George") &&
        author.getLastName().equals("Orwell")
    ));

    // Verify book was saved
    verify(mockBookRepo).save(argThat(book ->
        book.getTitle().equals("1984")
    ));
}
```

---

### Test 4: createNewBook() - Existing Author

```java
@Test
@DisplayName("createNewBook() with existing author should reuse author")
void createNewBook_WithExistingAuthor_ReusesAuthor() {
    // Arrange
    BookRequestDTO dto = new BookRequestDTO("Animal Farm", "George", "Orwell");

    AuthorEntity existingAuthor = new AuthorEntity("George", "Orwell");
    existingAuthor.setAuthorId(1L);

    when(mockAuthorRepo.findByFirstNameAndLastName("George", "Orwell"))
        .thenReturn(existingAuthor);  // Author EXISTS
    when(mockBookRepo.findByTitle("Animal Farm"))
        .thenReturn(null);  // Book doesn't exist

    // Act
    bookService.createNewBook(dto);

    // Assert
    // Verify author was NOT saved again
    verify(mockAuthorRepo, never()).save(any());

    // Verify book was saved
    verify(mockBookRepo).save(any(BookEntity.class));
}
```

---

### Test 5: checkOutBook() - Available Book

```java
@Test
@DisplayName("checkOutBook() when book is available should change status")
void checkOutBook_WhenAvailable_ChangesStatus() {
    // Arrange
    BookEntity book = new BookEntity();
    book.setBookId(1L);
    book.setTitle("1984");
    book.setBookStatus("AVAILABLE");

    // Act
    bookService.checkOutBook(book);

    // Assert
    assertThat(book.getBookStatus()).isEqualTo("CHECKED_OUT");
    verify(mockBookRepo).save(book);
}
```

---

### Test 6: checkOutBook() - Already Checked Out

```java
@Test
@DisplayName("checkOutBook() when already checked out should not change status")
void checkOutBook_WhenAlreadyCheckedOut_DoesNothing() {
    // Arrange
    BookEntity book = new BookEntity();
    book.setBookId(1L);
    book.setTitle("1984");
    book.setBookStatus("CHECKED_OUT");

    // Act
    bookService.checkOutBook(book);

    // Assert
    assertThat(book.getBookStatus()).isEqualTo("CHECKED_OUT");  // Unchanged
    verify(mockBookRepo, never()).save(any());  // Not saved
}
```

---

## Assertions and Matchers

### JUnit 5 Assertions

```java
import static org.junit.jupiter.api.Assertions.*;

// Equality
assertEquals(expected, actual);
assertEquals(expected, actual, "Custom failure message");

// Boolean
assertTrue(condition);
assertFalse(condition);

// Null
assertNull(object);
assertNotNull(object);

// Exceptions
Exception exception = assertThrows(ResponseStatusException.class, () -> {
    bookService.findBookByTitle("NonExistent");
});
assertEquals("Book not found", exception.getMessage());

// Timeouts
assertTimeout(Duration.ofSeconds(1), () -> {
    bookService.findAllBooks();
});

// Multiple assertions
assertAll(
    () -> assertEquals("1984", book.getTitle()),
    () -> assertEquals("AVAILABLE", book.getBookStatus()),
    () -> assertNotNull(book.getBookId())
);
```

---

### AssertJ Assertions (Recommended)

```java
import static org.assertj.core.api.Assertions.*;

// Objects
assertThat(book).isNotNull();
assertThat(book.getTitle()).isEqualTo("1984");
assertThat(book.getTitle()).isNotBlank();
assertThat(book.getTitle()).contains("84");
assertThat(book.getTitle()).startsWith("19").endsWith("84");

// Numbers
assertThat(book.getBookId()).isEqualTo(1L);
assertThat(books.size()).isGreaterThan(0);
assertThat(books.size()).isBetween(1, 10);

// Booleans
assertThat(book.getBookStatus().equals("AVAILABLE")).isTrue();

// Collections
assertThat(books).hasSize(3);
assertThat(books).isEmpty();
assertThat(books).isNotEmpty();
assertThat(books).contains(book1, book2);
assertThat(books).doesNotContain(book3);

// Extracting fields
assertThat(books)
    .extracting(BookEntity::getTitle)
    .containsExactly("1984", "Animal Farm", "Brave New World");

// Filtering
assertThat(books)
    .filteredOn(book -> book.getBookStatus().equals("AVAILABLE"))
    .hasSize(2);

// Exceptions
assertThatThrownBy(() -> bookService.findBookByTitle("NonExistent"))
    .isInstanceOf(ResponseStatusException.class)
    .hasMessageContaining("not found")
    .extracting("status")
    .isEqualTo(HttpStatus.NOT_FOUND);

// Optionals
assertThat(optionalBook).isPresent();
assertThat(optionalBook).isEmpty();
assertThat(optionalBook).hasValue(expectedBook);
```

**AssertJ is more fluent and readable. Use it!**

---

## Test Lifecycle

### Lifecycle Annotations

```java
@BeforeAll     // Runs ONCE before ALL tests (must be static)
@BeforeEach    // Runs before EACH test
@Test          // The test method
@AfterEach     // Runs after EACH test
@AfterAll      // Runs ONCE after ALL tests (must be static)
```

### Example

```java
class BookServiceTest {

    private static Database database;
    private BookService bookService;

    @BeforeAll
    static void initDatabase() {
        // Runs ONCE before all tests
        database = new Database();
        database.connect();
    }

    @BeforeEach
    void setUp() {
        // Runs before EACH test
        bookService = new BookService(mockRepo, mockAuthorRepo);
    }

    @Test
    void test1() {
        // Test code
    }

    @Test
    void test2() {
        // Test code
    }

    @AfterEach
    void tearDown() {
        // Runs after EACH test
        // Clean up test data
    }

    @AfterAll
    static void closeDatabase() {
        // Runs ONCE after all tests
        database.disconnect();
    }
}
```

**Execution Order:**
```
@BeforeAll (once)
  @BeforeEach
    test1()
  @AfterEach
  @BeforeEach
    test2()
  @AfterEach
@AfterAll (once)
```

---

## Testing Strategy for Bibby

### Priority 1: Service Layer Tests (Unit Tests)

**Why:** Services contain business logic (highest ROI).

**What to Test:**

1. **BookService**
   - createNewBook() with new author
   - createNewBook() with existing author
   - findBookByTitle() when exists
   - findBookByTitle() when not found
   - checkOutBook() when available
   - checkOutBook() when already checked out
   - checkInBook()

2. **BookcaseService**
   - createNewBookCase() when label doesn't exist
   - createNewBookCase() when label already exists (should throw)
   - findBookCaseById() when exists
   - findBookCaseById() when not found

3. **ShelfService**
   - findShelfById() when exists
   - findShelfById() when not found

4. **AuthorService**
   - (If you add business logic)

---

### Priority 2: Edge Cases & Error Handling

**Test error scenarios:**

```java
// Null inputs
@Test
void createNewBook_WithNullTitle_ThrowsException() { ... }

// Blank inputs
@Test
void createNewBook_WithBlankFirstName_ThrowsException() { ... }

// Invalid state transitions
@Test
void checkInBook_WhenAlreadyAvailable_DoesNothing() { ... }

// Not found scenarios
@Test
void addBookToShelf_WhenShelfNotFound_ThrowsException() { ... }
```

---

### Priority 3: Integration Tests (Optional)

**If time allows, test layers together:**

```java
@SpringBootTest
@Transactional  // Rollback after each test
class BookServiceIntegrationTest {

    @Autowired
    private BookService bookService;

    @Autowired
    private BookRepository bookRepository;

    @Test
    void createAndFindBook_EndToEnd() {
        // Create book
        BookRequestDTO dto = new BookRequestDTO("1984", "George", "Orwell");
        bookService.createNewBook(dto);

        // Find it
        Optional<BookEntity> found = bookService.findBookByTitle("1984");

        // Verify
        assertThat(found).isPresent();
        assertThat(found.get().getTitle()).isEqualTo("1984");
    }
}
```

---

### What NOT to Test (for Bibby)

❌ **Repository query methods** (trust Spring Data)
❌ **Entity getters/setters** (no logic)
❌ **CLI commands** (too complex for now, needs mocking stdin/stdout)
❌ **Spring Boot auto-configuration** (trust Spring)

---

### Suggested Test Files to Create

```
src/test/java/com/penrose/bibby/
  ├── library/
  │   ├── book/
  │   │   └── BookServiceTest.java          ← Priority 1
  │   ├── author/
  │   │   └── AuthorServiceTest.java        ← Priority 2
  │   ├── bookcase/
  │   │   └── BookcaseServiceTest.java      ← Priority 1
  │   └── shelf/
  │       └── ShelfServiceTest.java         ← Priority 2
  └── BibbyApplicationTests.java            ← Keep (context load)
```

**Target: 20-30 unit tests** (covers critical business logic)

---

## Action Items

### Priority 1 (Critical - Start Here)

- [ ] **Create BookServiceTest.java**
  - Test createNewBook() with new author
  - Test createNewBook() with existing author
  - Test findBookByTitle() happy path
  - Test findBookByTitle() not found
  - Test checkOutBook() when available
  - Test checkOutBook() when already checked out
  - **Target: 6 tests minimum**

- [ ] **Create BookcaseServiceTest.java**
  - Test createNewBookCase() success
  - Test createNewBookCase() duplicate label (should throw)
  - Test findBookCaseById() happy path
  - **Target: 3 tests minimum**

### Priority 2 (Important)

- [ ] **Add edge case tests to BookServiceTest**
  - Null title handling
  - Blank title handling
  - Case-insensitive search

- [ ] **Create ShelfServiceTest.java**
  - Test findShelfById() variations

### Priority 3 (Nice to Have)

- [ ] **Create integration test**
  - BookServiceIntegrationTest with real database
  - End-to-end workflow test

- [ ] **Add parameterized tests**
  - Test multiple book statuses with one test
  - Test multiple invalid inputs

### Not Recommended (Yet)

- ❌ Don't test CLI commands (complex, low ROI)
- ❌ Don't test repositories (Spring Data tested)
- ❌ Don't aim for 100% coverage (diminishing returns)

---

## Key Takeaways

### 1. Bibby Has Zero Real Tests

**Current:**
- 2 test files (1 empty context test, 1 placeholder)
- 0% business logic coverage
- No safety net for refactoring

**After Priority 1 Action Items:**
- 9+ unit tests covering critical business logic
- Confidence to refactor unsafe Optional.get() calls
- Safety net for future changes

---

### 2. Tests Are About Confidence, Not Coverage

**Don't:**
- Chase 100% coverage
- Test getters/setters
- Test Spring framework

**Do:**
- Test business logic
- Test edge cases
- Test error handling
- Use tests to document expected behavior

**80% coverage of critical logic > 100% coverage of everything**

---

### 3. Use the AAA Pattern

```
Arrange → Set up test data
Act     → Execute code under test
Assert  → Verify results
```

Every test should follow this structure. Makes tests readable and maintainable.

---

### 4. Unit Tests > Integration Tests > E2E Tests

**Testing Pyramid:**
- Many unit tests (fast, focused)
- Some integration tests (verify layers work together)
- Few E2E tests (verify critical workflows)

**For Bibby: Start with unit tests for services.**

---

### 5. Mock Dependencies in Unit Tests

```java
// ✅ Unit test (fast, isolated)
BookRepository mockRepo = mock(BookRepository.class);
when(mockRepo.findByTitleIgnoreCase("1984")).thenReturn(book);
BookService service = new BookService(mockRepo, null);

// ❌ Don't use real database in unit tests
BookService service = new BookService(realRepo, null);
```

Unit tests should be **fast** (milliseconds) and **isolated** (no database, no Spring context).

---

### 6. AssertJ > JUnit Assertions

```java
// ❌ JUnit (verbose)
assertNotNull(book);
assertEquals("1984", book.getTitle());

// ✅ AssertJ (fluent, readable)
assertThat(book).isNotNull();
assertThat(book.getTitle()).isEqualTo("1984");
```

AssertJ is included with spring-boot-starter-test. Use it!

---

### 7. Tests Are Living Documentation

```java
// Test names document behavior:
@Test
void createNewBook_WithNewAuthor_CreatesBoth() { ... }

@Test
void createNewBook_WithExistingAuthor_ReusesAuthor() { ... }

@Test
void checkOutBook_WhenAlreadyCheckedOut_DoesNothing() { ... }
```

Anyone reading these tests knows exactly how the system should behave.

---

### 8. Tests Enable Fearless Refactoring

**Without tests:**
- Refactor Optional.get() calls
- Cross fingers
- Manually test everything
- Hope nothing broke

**With tests:**
- Refactor Optional.get() calls
- Run tests (5 seconds)
- All green? Ship it!
- Red? Fix and re-run

**Tests are your safety net.**

---

## Practice Exercise

**Challenge:** Write your first real test for BookService.

**Steps:**

1. Create `src/test/java/com/penrose/bibby/library/book/BookServiceTest.java`

2. Set up test class:
```java
@DisplayName("BookService Tests")
class BookServiceTest {
    private BookService bookService;
    private BookRepository mockBookRepo;
    private AuthorRepository mockAuthorRepo;

    @BeforeEach
    void setUp() {
        mockBookRepo = mock(BookRepository.class);
        mockAuthorRepo = mock(AuthorRepository.class);
        bookService = new BookService(mockBookRepo, mockAuthorRepo);
    }
}
```

3. Write test for checkOutBook():
```java
@Test
@DisplayName("checkOutBook() when available should change status to CHECKED_OUT")
void checkOutBook_WhenAvailable_ChangesStatus() {
    // Arrange
    BookEntity book = new BookEntity();
    book.setBookStatus("AVAILABLE");

    // Act
    bookService.checkOutBook(book);

    // Assert
    assertThat(book.getBookStatus()).isEqualTo("CHECKED_OUT");
    verify(mockBookRepo).save(book);
}
```

4. Run test: `mvn test` or use IDE

5. Watch it pass!

**Bonus:** Write test for "already checked out" scenario.

---

**Mentor's Note:**

Your Bibby codebase has zero tests. This isn't unusual for early projects, but it's a critical gap.

Tests aren't about chasing coverage percentages. They're about **confidence**:
- Confidence to refactor those unsafe Optional.get() calls
- Confidence that createNewBook() handles edge cases correctly
- Confidence that you won't break existing features when adding new ones

Start small. Write 6 tests for BookService (Priority 1 action items). Run them. Watch them pass. Feel that confidence grow.

Then, when you refactor BookCommands.java:361-363 to use flatMap() (from Section 15), you'll have tests proving your business logic still works.

**Tests aren't documentation. Tests aren't quality gates. Tests are your safety net.**

Write enough tests to feel confident. No more, no less.

---

*Section 17 Complete — 65 min read*
*Next: Section 18 — Mockito & Mocking*
*Progress: 17 / 33 sections (52%)*
