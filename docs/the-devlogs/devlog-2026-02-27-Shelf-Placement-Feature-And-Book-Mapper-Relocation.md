# Devlog: Shelf Placement Feature and Book Mapper Relocation

Date: 2026-02-27
Time: 17:38 CST
Branch: `feat/shelf-placement-and-book-mapper-relocation`
Range: `44eecc7..4672154` (local main → branch tip, merged via PR #332)
Commits:

- `6286566` Relocate book mappers to infrastructure/adapter/mapping package
- `6840b3a` Fix findBookById null safety and add @Component to BookFacade
- `df6da16` Add global exception handler for IllegalArgumentException
- `a945752` Add book-to-shelf placement capability to shelf module
- `11484a3` Add unit tests for placement feature
- `4f4da43` Update stacks module documentation and closed-issue-11
- `4672154` Remove @Component annotation from BookFacade and add @Lazy annotation to BookAccessPortAdapter

---

## Summary

- **Problem:** There was no way to record that a specific book lives on a specific shelf. The placement concept existed as a standalone module but belonged inside the shelf bounded context. Meanwhile, the book module's mappers were misplaced, and a cross-context dependency (`BookAccessPortAdapter` → `BookFacade`) had wiring issues that surfaced as NPEs and circular bean dependencies.
- **Before:** Book-to-shelf assignment had no persistence. `BookMapper`/`BookMapperTwo` lived in `infrastructure/mapping/` instead of `infrastructure/adapter/mapping/`. `BookService.findBookById` threw NPE when a book wasn't found. Domain validation errors (`IllegalArgumentException`) bubbled up as HTTP 500s.
- **Outcomes:**
    - Placement is a first-class domain concept inside the shelf module with full hexagonal layering
    - Book mappers follow the same `infrastructure/adapter/mapping/` convention as the shelf module
    - `BookService.findBookById` is null-safe via `Optional.map`
    - Domain validation errors return structured 400 responses
    - Cross-context `BookFacade` dependency uses `@Lazy` to break the circular bean cycle
    - 13 new test methods covering placement across all layers

---

## Per-Commit Breakdown

### Commit 1: `6286566` — Relocate book mappers to infrastructure/adapter/mapping package

**Intent:** Align the book module's mapper location with the hex convention already used by the shelf module.

**Files touched:**

| File | Reason |
|---|---|
| `BookMapper.java` | Moved from `infrastructure/mapping/` → `infrastructure/adapter/mapping/` |
| `BookMapperTwo.java` | Same relocation |
| `IsbnEnrichmentService.java` | Import path updated |
| `BookDomainRepositoryImpl.java` | Import path updated |

**Key change:** Pure file move + import updates. No behavior change.

**Architecture notes:** Mappers are adapter-layer concerns — they translate between JPA entities and domain objects. Placing them under `infrastructure/adapter/mapping/` makes the boundary explicit: core never depends on them directly, only adapter code does.

**Risk:** Low. Import-only change. Any missed import would fail at compile time.

---

### Commit 2: `6840b3a` — Fix findBookById null safety and add @Component to BookFacade

**Intent:** Fix a runtime NPE in `BookService.findBookById` and prepare `BookFacade` for cross-context injection.

**Files touched:**

| File | Reason |
|---|---|
| `BookService.java` | `findBookById` rewritten for null safety |
| `BookFacade.java` | Added `@Component` to enable Spring discovery (later reverted in `4672154`) |
| `ShelfMapper.java` | Removed erroneous `setShelfId` call on new entities |

**Key code change — `BookService.findBookById`:**

```java
// Before (NPE when book not found):
BookEntity bookEntity = bookJpaRepository.findById(bookId).orElse(null);
return Optional.of(BookDTO.fromEntity(bookEntity));

// After (null-safe):
Optional<BookEntity> bookEntity = bookJpaRepository.findById(bookId);
return bookEntity.map(BookDTO::fromEntity);
```

**Architecture notes:**
- The `@Component` on `BookFacade` was an attempt to solve Spring's inability to inject the interface into `BookAccessPortAdapter`. This turned out to be the wrong fix (it was reverted in commit `4672154` in favor of `@Lazy`).
- Removing `setShelfId` from `ShelfMapper.toEntity` is correct: when creating a new shelf entity, the ID should be auto-generated by JPA, not set from a domain object that hasn't been persisted yet.

**Risk:** The `Optional.map` fix is strictly safer. The `@Component` on an interface is unusual — it worked but was architecturally wrong (resolved later).

---

### Commit 3: `df6da16` — Add global exception handler for IllegalArgumentException

**Intent:** Convert domain validation errors into structured HTTP 400 responses instead of 500s.

**Files touched:**

| File | Reason |
|---|---|
| `GlobalExceptionHandler.java` | New `@RestControllerAdvice` class |

**Key code:**

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
  @ExceptionHandler(IllegalArgumentException.class)
  public ResponseEntity<Map<String, String>> handleIllegalArgument(IllegalArgumentException ex) {
    return ResponseEntity.status(HttpStatus.BAD_REQUEST)
        .body(Map.of("error", ex.getMessage()));
  }
}
```

**Architecture notes:** This lives in `web.controllers` — the correct layer for HTTP concern translation. Domain code throws `IllegalArgumentException` (e.g., `PlaceBookOnShelfUseCase` when a book doesn't exist), and the web layer translates it to a 400 with a JSON error body. The domain stays HTTP-unaware.

**Risk:** This is a global catch — *any* `IllegalArgumentException` from anywhere in the app becomes a 400. If framework or library code throws `IllegalArgumentException` for a programming error, clients will see a 400 instead of a 500. A custom domain exception (e.g., `BookNotFoundException`) would be safer long-term but is fine for now.

---

### Commit 4: `a945752` — Add book-to-shelf placement capability to shelf module

**Intent:** Introduce the `Placement` domain concept and the full vertical slice to place a book on a shelf.

**This is the core commit.** 13 files changed, 214 insertions.

**Files touched:**

| File | Reason |
|---|---|
| `Placement.java` | New domain model — book-to-shelf assignment |
| `PlaceBookOnShelfUseCase.java` | New use case — validates book exists, creates Placement, persists |
| `ShelfFacade.java` | New method: `placeBookOnShelf(Long bookId, Long shelfId)` |
| `BookAccessPort.java` | New method: `getBookById(Long bookId)` |
| `PlacementRepositoryPort.java` | New outbound port for placement persistence |
| `BookAccessPortAdapter.java` | Implements `getBookById` via `BookFacade.findBookById` |
| `PlacementRepositoryPortImpl.java` | Adapter: maps `Placement` → `PlacementEntity`, saves via JPA |
| `PlacementEntity.java` | JPA entity for `placements` table |
| `PlacementMapper.java` | Static mapper: `Placement` → `PlacementEntity` |
| `PlacementJpaRepository.java` | Spring Data JPA repository |
| `ShelfService.java` | Wires `PlaceBookOnShelfUseCase`, delegates `placeBookOnShelf` |
| `ShelfController.java` | New `POST /api/v1/shelves/placements` endpoint |
| `BookController.java` | After creating a book, now also places it on its shelf via `ShelfFacade` |

**Critical flow — Place a book on a shelf:**

```
POST /api/v1/shelves/placements { bookId: 1, shelfId: 2 }
  → ShelfController.addBookToShelf(request)
    → ShelfFacade.placeBookOnShelf(1, 2)
      → ShelfService delegates to PlaceBookOnShelfUseCase.execute(1, 2)
        → BookAccessPort.getBookById(1)
          → BookAccessPortAdapter → BookFacade.findBookById(1) → returns Optional<BookDTO>
          → if empty → return null → use case throws IllegalArgumentException
        → new Placement(1, 2) (domain model with null-safety guards)
        → PlacementRepositoryPort.placeBookOnShelf(placement)
          → PlacementRepositoryPortImpl → PlacementMapper.toEntity() → JPA save
```

**Architecture notes:**

- `Placement` was pulled out of a standalone module into `shelf.core.domain.model` — correct, because a placement is a relationship managed by the shelf aggregate, not its own bounded context.
- The use case validates the book exists via `BookAccessPort` (outbound port), keeping the shelf core decoupled from the book module. The adapter translates.
- `BookAccessPortAdapter.getBookIdsByShelfId` now returns `List.of()` (stub) and `deleteBooksOnShelves` is a no-op. These were previously delegating to `BookFacade` methods that may have had issues. **Inference:** The stubs suggest these methods are being deferred to future work or were causing problems.
- `BookController.addNewBook` now calls `shelfFacade.placeBookOnShelf(...)` after creating a book, tying book creation to shelf placement in the controller layer.

**Risk:**

- `BookController` now depends on both `BookFacade` and `ShelfFacade`. This is a cross-context call from a controller — acceptable for now but could become a coordination concern.
- `BookAccessPortAdapter.getBookById` returns `null` when the book is not found, rather than `Optional`. The port contract documents this, but it's a leaky abstraction — the caller (use case) has to null-check.
- No shelf capacity check before placement: a book can be placed on a full shelf. The `isFull()` method exists on `Shelf` but is not called in `PlaceBookOnShelfUseCase`.
- No duplicate placement guard: the same book can be placed on the same shelf multiple times.

---

### Commit 5: `11484a3` — Add unit tests for placement feature

**Intent:** Full test coverage across all layers for the new placement code.

**Files touched:**

| File | Tests |
|---|---|
| `PlacementTest.java` | 6 tests — constructor, null getters/setters |
| `PlaceBookOnShelfUseCaseTest.java` | 3 tests — happy path, book-not-found, ordering |
| `PlacementRepositoryPortImplTest.java` | 2 tests — JPA save delegation |
| `PlacementMapperTest.java` | 2 tests — domain-to-entity field mapping |
| `ShelfServiceTest.java` | +1 test — delegation to `PlaceBookOnShelfUseCase` |
| `BookAccessPortAdapterTest.java` | Updated — `getBookById` tests, fixed stub assertions |

**Test quality notes:**
- Tests follow the established pattern: JUnit 5 + Mockito + AssertJ.
- `PlaceBookOnShelfUseCaseTest` verifies both the happy path (book exists → placement persisted) and the error path (book not found → `IllegalArgumentException` thrown, no save called). Uses `ArgumentCaptor` to verify the `Placement` object passed to the repository.
- `BookAccessPortAdapterTest` was updated to reflect the stubbed-out methods (`getBookIdsByShelfId` returns empty list, `deleteBooksOnShelves` is a no-op) and added `getBookById` tests for both found and not-found cases.

**Risk:** `BibbyApplicationTests` (Spring context load) fails due to DB connectivity — pre-existing and unrelated.

---

### Commit 6: `4f4da43` — Update stacks module documentation and closed-issue-11

**Intent:** Documentation catch-up.

**Files touched:**

| File | Reason |
|---|---|
| `stacks/README.md` | Comprehensive rewrite to reflect current module structure |
| `closed-issue-11.md` | Formatting/wrapping updates |

No code changes.

---

### Commit 7: `4672154` — Remove @Component from BookFacade, add @Lazy to BookAccessPortAdapter

**Intent:** Fix the circular bean dependency between Stacks and Cataloging the right way.

**Files touched:**

| File | Reason |
|---|---|
| `BookFacade.java` | Removed `@Component` (reverts commit `6840b3a`'s annotation) |
| `BookAccessPortAdapter.java` | Added `@Lazy` to `BookFacade` constructor parameter |

**Key code:**

```java
// BookAccessPortAdapter — breaks the circular dependency at the adapter boundary
public BookAccessPortAdapter(@Lazy BookFacade bookFacade) {
    this.bookFacade = bookFacade;
}
```

**Architecture notes:** `@Component` on `BookFacade` (an interface) was wrong — it told Spring to discover the interface itself as a bean, which conflicted with the `@Service`-annotated `BookService` implementation. `@Lazy` on the injection point is the correct fix: it defers proxy creation until first use, breaking the `BookAccessPortAdapter → BookFacade → BookService → ... → ShelfFacade → ShelfService → ... → BookAccessPort → BookAccessPortAdapter` cycle without polluting the domain interface with framework annotations.

**Risk:** `@Lazy` introduces a runtime proxy. The dependency isn't validated at startup — a misconfiguration would fail at first use, not at boot. This is a known tradeoff and acceptable for cross-context adapter wiring.

---

## End-to-End Architecture Analysis

### Dependency flow (after this push)

```
Web Layer (BookController, ShelfController)
    ↓ depends on
Inbound Ports (BookFacade, ShelfFacade)
    ↓ implemented by
Application Services (BookService, ShelfService)
    ↓ delegates to
Use Cases (PlaceBookOnShelfUseCase, etc.)
    ↓ depends on
Outbound Ports (BookAccessPort, PlacementRepositoryPort, ShelfDomainRepositoryPort)
    ↓ implemented by
Adapters (BookAccessPortAdapter, PlacementRepositoryPortImpl)
    ↓ depends on
Infrastructure (BookFacade/@Lazy, PlacementJpaRepository)
```

Cross-context boundary: `Stacks/Shelf → Cataloging/Book` goes through `BookAccessPort` (outbound port in shelf core) → `BookAccessPortAdapter` (infrastructure adapter) → `BookFacade` (inbound port in cataloging core). The `@Lazy` annotation lives on the adapter, keeping the port and core clean of framework annotations.

### What got better

1. **Placement has a home.** Instead of a floating standalone module, it's part of the shelf aggregate where it belongs.
2. **Book mappers follow convention.** `infrastructure/adapter/mapping/` is consistent across both cataloging and stacks modules.
3. **Null safety.** `BookService.findBookById` no longer throws NPE on missing books.
4. **Error responses.** Domain validation errors return 400 with a message instead of 500 stacktraces.
5. **Circular dependency solved cleanly.** `@Lazy` on the adapter injection point — no framework annotations leak into core interfaces.

### What needs attention

1. **No shelf capacity check on placement.** `PlaceBookOnShelfUseCase` does not call `Shelf.isFull()` before persisting. A book can be placed on a shelf that's already at capacity.
2. **No duplicate placement guard.** The same `(bookId, shelfId)` pair can be inserted multiple times into the `placements` table.
3. **Stubbed-out methods in `BookAccessPortAdapter`.** `getBookIdsByShelfId` returns `List.of()` and `deleteBooksOnShelves` is a no-op. Shelves currently cannot report which books they hold from the database.
4. **`BookController` cross-context coupling.** `addNewBook` calls both `bookFacade.createNewBook(...)` and `shelfFacade.placeBookOnShelf(...)`. If the placement fails, the book is already created — no transactional consistency across the two contexts.
5. **`GlobalExceptionHandler` is broad.** Catches all `IllegalArgumentException`, including framework/library ones. A custom exception hierarchy would be more precise.

---

## Test Coverage

### Existing tests (new in this push)

| Test Class | Count | Layer |
|---|---|---|
| `PlacementTest` | 6 | Domain model |
| `PlaceBookOnShelfUseCaseTest` | 3 | Application / use case |
| `PlacementRepositoryPortImplTest` | 2 | Infrastructure adapter |
| `PlacementMapperTest` | 2 | Infrastructure mapping |
| `ShelfServiceTest` (updated) | +1 | Application service delegation |
| `BookAccessPortAdapterTest` (updated) | +1 | Infrastructure adapter |

### Suggested additional tests

1. **`PlaceBookOnShelfUseCase` — null bookId/shelfId:** Verify behavior when `execute(null, 2L)` or `execute(1L, null)` is called. Currently the `Placement` constructor accepts nulls; the guard is only on `getBookId()`.
2. **`ShelfController` integration test:** `POST /api/v1/shelves/placements` with valid body, invalid body (missing fields), and non-existent book ID.
3. **`BookController` placement integration:** Verify that `addNewBook` actually places the book on the shelf after creation.
4. **`GlobalExceptionHandler` test:** Confirm 400 response body structure (`{"error": "..."}`) for `IllegalArgumentException`.

### Commands

```bash
# Run all shelf-related tests
mvn test -pl . -Dtest="com.penrose.bibby.library.stacks.shelf.**"

# Run only placement tests
mvn test -pl . -Dtest="PlacementTest,PlaceBookOnShelfUseCaseTest,PlacementRepositoryPortImplTest,PlacementMapperTest"

# Run full suite (note: BibbyApplicationTests will fail without DB)
mvn test
```

---

## Lessons from This Push

1. **Fix the wiring problem last, not first.** Commits `6840b3a` (add `@Component` to `BookFacade`) and `4672154` (revert it, use `@Lazy`) show the cost of guessing at DI fixes. The first attempt polluted a core interface with a framework annotation. The correct fix (`@Lazy` on the adapter) keeps the boundary clean.
2. **Stub methods are tech debt — label them.** `getBookIdsByShelfId` returning `List.of()` is invisible unless you read the adapter code. A `// TODO` or a logging warning would surface this faster.
3. **Domain validation needs an error strategy.** Using `IllegalArgumentException` for "book not found" works today but will collide with framework exceptions when the `GlobalExceptionHandler` catches too broadly.
4. **Cross-context calls from controllers need coordination.** `BookController.addNewBook` creating a book then placing it is two separate operations with no shared transaction. This is a known DDD challenge — consider a domain event or application-level saga if consistency matters.
5. **Relocating files pays off immediately.** The mapper move (`6286566`) was 4 lines of import changes. Small investment, big clarity gain — now both modules follow the same convention.

---

## Next Steps

### Immediate (today)

- Add a unique constraint on `(bookId, shelfId)` in `PlacementEntity` or `PlacementJpaRepository` to prevent duplicate placements
- Add shelf capacity validation in `PlaceBookOnShelfUseCase` before persisting the placement

### Short-term (this week)

- Implement `BookAccessPortAdapter.getBookIdsByShelfId` using `PlacementJpaRepository` queries so shelves can report their books
- Replace `IllegalArgumentException` in `PlaceBookOnShelfUseCase` with a custom `BookNotFoundException` and update `GlobalExceptionHandler`
- Add integration tests for `ShelfController.addBookToShelf` and `BookController.addNewBook` placement flow

### Strategic (later)

- Consider a domain event (`BookCreatedEvent`) to decouple `BookController` from `ShelfFacade` — book creation publishes an event, a listener in the shelf context handles placement
- Reconcile `Placement` persistence with `Shelf.books` field — currently two separate data paths that aren't connected
- Evaluate whether `deleteBooksOnShelves` should cascade-delete placements or just clear the association
